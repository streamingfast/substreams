const INTERNAL_ERR: &'static str = "`ethabi_derive` internal error";
/// Contract's functions.
#[allow(dead_code, unused_imports, unused_variables)]
pub mod functions {
use super::INTERNAL_ERR;
#[derive(Debug, Clone, PartialEq)]
pub struct Approve {
    pub to: Vec<u8>,
    pub token_id: substreams::scalar::BigInt,
}
impl Approve {
    const METHOD_ID: [u8; 4] = [9u8, 94u8, 167u8, 179u8];
    pub fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        let maybe_data = call.input.get(4..);
        if maybe_data.is_none() {
            return Err("no data to decode".to_string());
        }
        let mut values = ethabi::decode(
                &[ethabi::ParamType::Address, ethabi::ParamType::Uint(256usize)],
                maybe_data.unwrap(),
            )
            .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
        values.reverse();
        Ok(Self {
            to: values
                .pop()
                .expect(INTERNAL_ERR)
                .into_address()
                .expect(INTERNAL_ERR)
                .as_bytes()
                .to_vec(),
            token_id: {
                let mut v = [0 as u8; 32];
                values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_uint()
                    .expect(INTERNAL_ERR)
                    .to_big_endian(v.as_mut_slice());
                substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
            },
        })
    }
    pub fn encode(&self) -> Vec<u8> {
        let data = ethabi::encode(
            &[
                ethabi::Token::Address(ethabi::Address::from_slice(&self.to)),
                ethabi::Token::Uint(
                    ethabi::Uint::from_big_endian(
                        match self.token_id.clone().to_bytes_be() {
                            (num_bigint::Sign::Plus, bytes) => bytes,
                            (num_bigint::Sign::NoSign, bytes) => bytes,
                            (num_bigint::Sign::Minus, _) => {
                                panic!("negative numbers are not supported")
                            }
                        }
                            .as_slice(),
                    ),
                ),
            ],
        );
        let mut encoded = Vec::with_capacity(4 + data.len());
        encoded.extend(Self::METHOD_ID);
        encoded.extend(data);
        encoded
    }
    pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        match call.input.get(0..4) {
            Some(signature) => Self::METHOD_ID == signature,
            None => false,
        }
    }
}
impl substreams_ethereum::Function for Approve {
    const NAME: &'static str = "approve";
    fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        Self::match_call(call)
    }
    fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        Self::decode(call)
    }
    fn encode(&self) -> Vec<u8> {
        self.encode()
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct BalanceOf {
    pub owner: Vec<u8>,
}
impl BalanceOf {
    const METHOD_ID: [u8; 4] = [112u8, 160u8, 130u8, 49u8];
    pub fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        let maybe_data = call.input.get(4..);
        if maybe_data.is_none() {
            return Err("no data to decode".to_string());
        }
        let mut values = ethabi::decode(
                &[ethabi::ParamType::Address],
                maybe_data.unwrap(),
            )
            .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
        values.reverse();
        Ok(Self {
            owner: values
                .pop()
                .expect(INTERNAL_ERR)
                .into_address()
                .expect(INTERNAL_ERR)
                .as_bytes()
                .to_vec(),
        })
    }
    pub fn encode(&self) -> Vec<u8> {
        let data = ethabi::encode(
            &[ethabi::Token::Address(ethabi::Address::from_slice(&self.owner))],
        );
        let mut encoded = Vec::with_capacity(4 + data.len());
        encoded.extend(Self::METHOD_ID);
        encoded.extend(data);
        encoded
    }
    pub fn output_call(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<substreams::scalar::BigInt, String> {
        Self::output(call.return_data.as_ref())
    }
    pub fn output(data: &[u8]) -> Result<substreams::scalar::BigInt, String> {
        let mut values = ethabi::decode(
                &[ethabi::ParamType::Uint(256usize)],
                data.as_ref(),
            )
            .map_err(|e| format!("unable to decode output data: {:?}", e))?;
        Ok({
            let mut v = [0 as u8; 32];
            values
                .pop()
                .expect("one output data should have existed")
                .into_uint()
                .expect(INTERNAL_ERR)
                .to_big_endian(v.as_mut_slice());
            substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
        })
    }
    pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        match call.input.get(0..4) {
            Some(signature) => Self::METHOD_ID == signature,
            None => false,
        }
    }
    pub fn call(&self, address: Vec<u8>) -> Option<substreams::scalar::BigInt> {
        use substreams_ethereum::pb::eth::rpc;
        let rpc_calls = rpc::RpcCalls {
            calls: vec![
                rpc::RpcCall { to_addr : address, data : self.encode(), }
            ],
        };
        let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
        let response = responses
            .get(0)
            .expect("one response should have existed");
        if response.failed {
            return None;
        }
        match Self::output(response.raw.as_ref()) {
            Ok(data) => Some(data),
            Err(err) => {
                use substreams_ethereum::Function;
                substreams::log::info!(
                    "Call output for function `{}` failed to decode with error: {}",
                    Self::NAME, err
                );
                None
            }
        }
    }
}
impl substreams_ethereum::Function for BalanceOf {
    const NAME: &'static str = "balanceOf";
    fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        Self::match_call(call)
    }
    fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        Self::decode(call)
    }
    fn encode(&self) -> Vec<u8> {
        self.encode()
    }
}
impl substreams_ethereum::rpc::RPCDecodable<substreams::scalar::BigInt>
for BalanceOf {
    fn output(data: &[u8]) -> Result<substreams::scalar::BigInt, String> {
        Self::output(data)
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct GetApproved {
    pub token_id: substreams::scalar::BigInt,
}
impl GetApproved {
    const METHOD_ID: [u8; 4] = [8u8, 24u8, 18u8, 252u8];
    pub fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        let maybe_data = call.input.get(4..);
        if maybe_data.is_none() {
            return Err("no data to decode".to_string());
        }
        let mut values = ethabi::decode(
                &[ethabi::ParamType::Uint(256usize)],
                maybe_data.unwrap(),
            )
            .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
        values.reverse();
        Ok(Self {
            token_id: {
                let mut v = [0 as u8; 32];
                values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_uint()
                    .expect(INTERNAL_ERR)
                    .to_big_endian(v.as_mut_slice());
                substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
            },
        })
    }
    pub fn encode(&self) -> Vec<u8> {
        let data = ethabi::encode(
            &[
                ethabi::Token::Uint(
                    ethabi::Uint::from_big_endian(
                        match self.token_id.clone().to_bytes_be() {
                            (num_bigint::Sign::Plus, bytes) => bytes,
                            (num_bigint::Sign::NoSign, bytes) => bytes,
                            (num_bigint::Sign::Minus, _) => {
                                panic!("negative numbers are not supported")
                            }
                        }
                            .as_slice(),
                    ),
                ),
            ],
        );
        let mut encoded = Vec::with_capacity(4 + data.len());
        encoded.extend(Self::METHOD_ID);
        encoded.extend(data);
        encoded
    }
    pub fn output_call(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Vec<u8>, String> {
        Self::output(call.return_data.as_ref())
    }
    pub fn output(data: &[u8]) -> Result<Vec<u8>, String> {
        let mut values = ethabi::decode(
                &[ethabi::ParamType::Address],
                data.as_ref(),
            )
            .map_err(|e| format!("unable to decode output data: {:?}", e))?;
        Ok(
            values
                .pop()
                .expect("one output data should have existed")
                .into_address()
                .expect(INTERNAL_ERR)
                .as_bytes()
                .to_vec(),
        )
    }
    pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        match call.input.get(0..4) {
            Some(signature) => Self::METHOD_ID == signature,
            None => false,
        }
    }
    pub fn call(&self, address: Vec<u8>) -> Option<Vec<u8>> {
        use substreams_ethereum::pb::eth::rpc;
        let rpc_calls = rpc::RpcCalls {
            calls: vec![
                rpc::RpcCall { to_addr : address, data : self.encode(), }
            ],
        };
        let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
        let response = responses
            .get(0)
            .expect("one response should have existed");
        if response.failed {
            return None;
        }
        match Self::output(response.raw.as_ref()) {
            Ok(data) => Some(data),
            Err(err) => {
                use substreams_ethereum::Function;
                substreams::log::info!(
                    "Call output for function `{}` failed to decode with error: {}",
                    Self::NAME, err
                );
                None
            }
        }
    }
}
impl substreams_ethereum::Function for GetApproved {
    const NAME: &'static str = "getApproved";
    fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        Self::match_call(call)
    }
    fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        Self::decode(call)
    }
    fn encode(&self) -> Vec<u8> {
        self.encode()
    }
}
impl substreams_ethereum::rpc::RPCDecodable<Vec<u8>> for GetApproved {
    fn output(data: &[u8]) -> Result<Vec<u8>, String> {
        Self::output(data)
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct IsApprovedForAll {
    pub owner: Vec<u8>,
    pub operator: Vec<u8>,
}
impl IsApprovedForAll {
    const METHOD_ID: [u8; 4] = [233u8, 133u8, 233u8, 197u8];
    pub fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        let maybe_data = call.input.get(4..);
        if maybe_data.is_none() {
            return Err("no data to decode".to_string());
        }
        let mut values = ethabi::decode(
                &[ethabi::ParamType::Address, ethabi::ParamType::Address],
                maybe_data.unwrap(),
            )
            .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
        values.reverse();
        Ok(Self {
            owner: values
                .pop()
                .expect(INTERNAL_ERR)
                .into_address()
                .expect(INTERNAL_ERR)
                .as_bytes()
                .to_vec(),
            operator: values
                .pop()
                .expect(INTERNAL_ERR)
                .into_address()
                .expect(INTERNAL_ERR)
                .as_bytes()
                .to_vec(),
        })
    }
    pub fn encode(&self) -> Vec<u8> {
        let data = ethabi::encode(
            &[
                ethabi::Token::Address(ethabi::Address::from_slice(&self.owner)),
                ethabi::Token::Address(
                    ethabi::Address::from_slice(&self.operator),
                ),
            ],
        );
        let mut encoded = Vec::with_capacity(4 + data.len());
        encoded.extend(Self::METHOD_ID);
        encoded.extend(data);
        encoded
    }
    pub fn output_call(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<bool, String> {
        Self::output(call.return_data.as_ref())
    }
    pub fn output(data: &[u8]) -> Result<bool, String> {
        let mut values = ethabi::decode(
                &[ethabi::ParamType::Bool],
                data.as_ref(),
            )
            .map_err(|e| format!("unable to decode output data: {:?}", e))?;
        Ok(
            values
                .pop()
                .expect("one output data should have existed")
                .into_bool()
                .expect(INTERNAL_ERR),
        )
    }
    pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        match call.input.get(0..4) {
            Some(signature) => Self::METHOD_ID == signature,
            None => false,
        }
    }
    pub fn call(&self, address: Vec<u8>) -> Option<bool> {
        use substreams_ethereum::pb::eth::rpc;
        let rpc_calls = rpc::RpcCalls {
            calls: vec![
                rpc::RpcCall { to_addr : address, data : self.encode(), }
            ],
        };
        let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
        let response = responses
            .get(0)
            .expect("one response should have existed");
        if response.failed {
            return None;
        }
        match Self::output(response.raw.as_ref()) {
            Ok(data) => Some(data),
            Err(err) => {
                use substreams_ethereum::Function;
                substreams::log::info!(
                    "Call output for function `{}` failed to decode with error: {}",
                    Self::NAME, err
                );
                None
            }
        }
    }
}
impl substreams_ethereum::Function for IsApprovedForAll {
    const NAME: &'static str = "isApprovedForAll";
    fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        Self::match_call(call)
    }
    fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        Self::decode(call)
    }
    fn encode(&self) -> Vec<u8> {
        self.encode()
    }
}
impl substreams_ethereum::rpc::RPCDecodable<bool> for IsApprovedForAll {
    fn output(data: &[u8]) -> Result<bool, String> {
        Self::output(data)
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct Name {}
impl Name {
    const METHOD_ID: [u8; 4] = [6u8, 253u8, 222u8, 3u8];
    pub fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        Ok(Self {})
    }
    pub fn encode(&self) -> Vec<u8> {
        let data = ethabi::encode(&[]);
        let mut encoded = Vec::with_capacity(4 + data.len());
        encoded.extend(Self::METHOD_ID);
        encoded.extend(data);
        encoded
    }
    pub fn output_call(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<String, String> {
        Self::output(call.return_data.as_ref())
    }
    pub fn output(data: &[u8]) -> Result<String, String> {
        let mut values = ethabi::decode(
                &[ethabi::ParamType::String],
                data.as_ref(),
            )
            .map_err(|e| format!("unable to decode output data: {:?}", e))?;
        Ok(
            values
                .pop()
                .expect("one output data should have existed")
                .into_string()
                .expect(INTERNAL_ERR),
        )
    }
    pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        match call.input.get(0..4) {
            Some(signature) => Self::METHOD_ID == signature,
            None => false,
        }
    }
    pub fn call(&self, address: Vec<u8>) -> Option<String> {
        use substreams_ethereum::pb::eth::rpc;
        let rpc_calls = rpc::RpcCalls {
            calls: vec![
                rpc::RpcCall { to_addr : address, data : self.encode(), }
            ],
        };
        let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
        let response = responses
            .get(0)
            .expect("one response should have existed");
        if response.failed {
            return None;
        }
        match Self::output(response.raw.as_ref()) {
            Ok(data) => Some(data),
            Err(err) => {
                use substreams_ethereum::Function;
                substreams::log::info!(
                    "Call output for function `{}` failed to decode with error: {}",
                    Self::NAME, err
                );
                None
            }
        }
    }
}
impl substreams_ethereum::Function for Name {
    const NAME: &'static str = "name";
    fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        Self::match_call(call)
    }
    fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        Self::decode(call)
    }
    fn encode(&self) -> Vec<u8> {
        self.encode()
    }
}
impl substreams_ethereum::rpc::RPCDecodable<String> for Name {
    fn output(data: &[u8]) -> Result<String, String> {
        Self::output(data)
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct OwnerOf {
    pub token_id: substreams::scalar::BigInt,
}
impl OwnerOf {
    const METHOD_ID: [u8; 4] = [99u8, 82u8, 33u8, 30u8];
    pub fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        let maybe_data = call.input.get(4..);
        if maybe_data.is_none() {
            return Err("no data to decode".to_string());
        }
        let mut values = ethabi::decode(
                &[ethabi::ParamType::Uint(256usize)],
                maybe_data.unwrap(),
            )
            .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
        values.reverse();
        Ok(Self {
            token_id: {
                let mut v = [0 as u8; 32];
                values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_uint()
                    .expect(INTERNAL_ERR)
                    .to_big_endian(v.as_mut_slice());
                substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
            },
        })
    }
    pub fn encode(&self) -> Vec<u8> {
        let data = ethabi::encode(
            &[
                ethabi::Token::Uint(
                    ethabi::Uint::from_big_endian(
                        match self.token_id.clone().to_bytes_be() {
                            (num_bigint::Sign::Plus, bytes) => bytes,
                            (num_bigint::Sign::NoSign, bytes) => bytes,
                            (num_bigint::Sign::Minus, _) => {
                                panic!("negative numbers are not supported")
                            }
                        }
                            .as_slice(),
                    ),
                ),
            ],
        );
        let mut encoded = Vec::with_capacity(4 + data.len());
        encoded.extend(Self::METHOD_ID);
        encoded.extend(data);
        encoded
    }
    pub fn output_call(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Vec<u8>, String> {
        Self::output(call.return_data.as_ref())
    }
    pub fn output(data: &[u8]) -> Result<Vec<u8>, String> {
        let mut values = ethabi::decode(
                &[ethabi::ParamType::Address],
                data.as_ref(),
            )
            .map_err(|e| format!("unable to decode output data: {:?}", e))?;
        Ok(
            values
                .pop()
                .expect("one output data should have existed")
                .into_address()
                .expect(INTERNAL_ERR)
                .as_bytes()
                .to_vec(),
        )
    }
    pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        match call.input.get(0..4) {
            Some(signature) => Self::METHOD_ID == signature,
            None => false,
        }
    }
    pub fn call(&self, address: Vec<u8>) -> Option<Vec<u8>> {
        use substreams_ethereum::pb::eth::rpc;
        let rpc_calls = rpc::RpcCalls {
            calls: vec![
                rpc::RpcCall { to_addr : address, data : self.encode(), }
            ],
        };
        let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
        let response = responses
            .get(0)
            .expect("one response should have existed");
        if response.failed {
            return None;
        }
        match Self::output(response.raw.as_ref()) {
            Ok(data) => Some(data),
            Err(err) => {
                use substreams_ethereum::Function;
                substreams::log::info!(
                    "Call output for function `{}` failed to decode with error: {}",
                    Self::NAME, err
                );
                None
            }
        }
    }
}
impl substreams_ethereum::Function for OwnerOf {
    const NAME: &'static str = "ownerOf";
    fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        Self::match_call(call)
    }
    fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        Self::decode(call)
    }
    fn encode(&self) -> Vec<u8> {
        self.encode()
    }
}
impl substreams_ethereum::rpc::RPCDecodable<Vec<u8>> for OwnerOf {
    fn output(data: &[u8]) -> Result<Vec<u8>, String> {
        Self::output(data)
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct SafeTransferFrom1 {
    pub from: Vec<u8>,
    pub to: Vec<u8>,
    pub token_id: substreams::scalar::BigInt,
}
impl SafeTransferFrom1 {
    const METHOD_ID: [u8; 4] = [66u8, 132u8, 46u8, 14u8];
    pub fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        let maybe_data = call.input.get(4..);
        if maybe_data.is_none() {
            return Err("no data to decode".to_string());
        }
        let mut values = ethabi::decode(
                &[
                    ethabi::ParamType::Address,
                    ethabi::ParamType::Address,
                    ethabi::ParamType::Uint(256usize),
                ],
                maybe_data.unwrap(),
            )
            .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
        values.reverse();
        Ok(Self {
            from: values
                .pop()
                .expect(INTERNAL_ERR)
                .into_address()
                .expect(INTERNAL_ERR)
                .as_bytes()
                .to_vec(),
            to: values
                .pop()
                .expect(INTERNAL_ERR)
                .into_address()
                .expect(INTERNAL_ERR)
                .as_bytes()
                .to_vec(),
            token_id: {
                let mut v = [0 as u8; 32];
                values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_uint()
                    .expect(INTERNAL_ERR)
                    .to_big_endian(v.as_mut_slice());
                substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
            },
        })
    }
    pub fn encode(&self) -> Vec<u8> {
        let data = ethabi::encode(
            &[
                ethabi::Token::Address(ethabi::Address::from_slice(&self.from)),
                ethabi::Token::Address(ethabi::Address::from_slice(&self.to)),
                ethabi::Token::Uint(
                    ethabi::Uint::from_big_endian(
                        match self.token_id.clone().to_bytes_be() {
                            (num_bigint::Sign::Plus, bytes) => bytes,
                            (num_bigint::Sign::NoSign, bytes) => bytes,
                            (num_bigint::Sign::Minus, _) => {
                                panic!("negative numbers are not supported")
                            }
                        }
                            .as_slice(),
                    ),
                ),
            ],
        );
        let mut encoded = Vec::with_capacity(4 + data.len());
        encoded.extend(Self::METHOD_ID);
        encoded.extend(data);
        encoded
    }
    pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        match call.input.get(0..4) {
            Some(signature) => Self::METHOD_ID == signature,
            None => false,
        }
    }
}
impl substreams_ethereum::Function for SafeTransferFrom1 {
    const NAME: &'static str = "safeTransferFrom1";
    fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        Self::match_call(call)
    }
    fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        Self::decode(call)
    }
    fn encode(&self) -> Vec<u8> {
        self.encode()
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct SafeTransferFrom2 {
    pub from: Vec<u8>,
    pub to: Vec<u8>,
    pub token_id: substreams::scalar::BigInt,
    pub data: Vec<u8>,
}
impl SafeTransferFrom2 {
    const METHOD_ID: [u8; 4] = [184u8, 141u8, 79u8, 222u8];
    pub fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        let maybe_data = call.input.get(4..);
        if maybe_data.is_none() {
            return Err("no data to decode".to_string());
        }
        let mut values = ethabi::decode(
                &[
                    ethabi::ParamType::Address,
                    ethabi::ParamType::Address,
                    ethabi::ParamType::Uint(256usize),
                    ethabi::ParamType::Bytes,
                ],
                maybe_data.unwrap(),
            )
            .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
        values.reverse();
        Ok(Self {
            from: values
                .pop()
                .expect(INTERNAL_ERR)
                .into_address()
                .expect(INTERNAL_ERR)
                .as_bytes()
                .to_vec(),
            to: values
                .pop()
                .expect(INTERNAL_ERR)
                .into_address()
                .expect(INTERNAL_ERR)
                .as_bytes()
                .to_vec(),
            token_id: {
                let mut v = [0 as u8; 32];
                values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_uint()
                    .expect(INTERNAL_ERR)
                    .to_big_endian(v.as_mut_slice());
                substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
            },
            data: values
                .pop()
                .expect(INTERNAL_ERR)
                .into_bytes()
                .expect(INTERNAL_ERR),
        })
    }
    pub fn encode(&self) -> Vec<u8> {
        let data = ethabi::encode(
            &[
                ethabi::Token::Address(ethabi::Address::from_slice(&self.from)),
                ethabi::Token::Address(ethabi::Address::from_slice(&self.to)),
                ethabi::Token::Uint(
                    ethabi::Uint::from_big_endian(
                        match self.token_id.clone().to_bytes_be() {
                            (num_bigint::Sign::Plus, bytes) => bytes,
                            (num_bigint::Sign::NoSign, bytes) => bytes,
                            (num_bigint::Sign::Minus, _) => {
                                panic!("negative numbers are not supported")
                            }
                        }
                            .as_slice(),
                    ),
                ),
                ethabi::Token::Bytes(self.data.clone()),
            ],
        );
        let mut encoded = Vec::with_capacity(4 + data.len());
        encoded.extend(Self::METHOD_ID);
        encoded.extend(data);
        encoded
    }
    pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        match call.input.get(0..4) {
            Some(signature) => Self::METHOD_ID == signature,
            None => false,
        }
    }
}
impl substreams_ethereum::Function for SafeTransferFrom2 {
    const NAME: &'static str = "safeTransferFrom2";
    fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        Self::match_call(call)
    }
    fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        Self::decode(call)
    }
    fn encode(&self) -> Vec<u8> {
        self.encode()
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct SetApprovalForAll {
    pub operator: Vec<u8>,
    pub approved: bool,
}
impl SetApprovalForAll {
    const METHOD_ID: [u8; 4] = [162u8, 44u8, 180u8, 101u8];
    pub fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        let maybe_data = call.input.get(4..);
        if maybe_data.is_none() {
            return Err("no data to decode".to_string());
        }
        let mut values = ethabi::decode(
                &[ethabi::ParamType::Address, ethabi::ParamType::Bool],
                maybe_data.unwrap(),
            )
            .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
        values.reverse();
        Ok(Self {
            operator: values
                .pop()
                .expect(INTERNAL_ERR)
                .into_address()
                .expect(INTERNAL_ERR)
                .as_bytes()
                .to_vec(),
            approved: values
                .pop()
                .expect(INTERNAL_ERR)
                .into_bool()
                .expect(INTERNAL_ERR),
        })
    }
    pub fn encode(&self) -> Vec<u8> {
        let data = ethabi::encode(
            &[
                ethabi::Token::Address(
                    ethabi::Address::from_slice(&self.operator),
                ),
                ethabi::Token::Bool(self.approved),
            ],
        );
        let mut encoded = Vec::with_capacity(4 + data.len());
        encoded.extend(Self::METHOD_ID);
        encoded.extend(data);
        encoded
    }
    pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        match call.input.get(0..4) {
            Some(signature) => Self::METHOD_ID == signature,
            None => false,
        }
    }
}
impl substreams_ethereum::Function for SetApprovalForAll {
    const NAME: &'static str = "setApprovalForAll";
    fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        Self::match_call(call)
    }
    fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        Self::decode(call)
    }
    fn encode(&self) -> Vec<u8> {
        self.encode()
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct SupportsInterface {
    pub interface_id: [u8; 4usize],
}
impl SupportsInterface {
    const METHOD_ID: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
    pub fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        let maybe_data = call.input.get(4..);
        if maybe_data.is_none() {
            return Err("no data to decode".to_string());
        }
        let mut values = ethabi::decode(
                &[ethabi::ParamType::FixedBytes(4usize)],
                maybe_data.unwrap(),
            )
            .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
        values.reverse();
        Ok(Self {
            interface_id: {
                let mut result = [0u8; 4];
                let v = values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_fixed_bytes()
                    .expect(INTERNAL_ERR);
                result.copy_from_slice(&v);
                result
            },
        })
    }
    pub fn encode(&self) -> Vec<u8> {
        let data = ethabi::encode(
            &[ethabi::Token::FixedBytes(self.interface_id.as_ref().to_vec())],
        );
        let mut encoded = Vec::with_capacity(4 + data.len());
        encoded.extend(Self::METHOD_ID);
        encoded.extend(data);
        encoded
    }
    pub fn output_call(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<bool, String> {
        Self::output(call.return_data.as_ref())
    }
    pub fn output(data: &[u8]) -> Result<bool, String> {
        let mut values = ethabi::decode(
                &[ethabi::ParamType::Bool],
                data.as_ref(),
            )
            .map_err(|e| format!("unable to decode output data: {:?}", e))?;
        Ok(
            values
                .pop()
                .expect("one output data should have existed")
                .into_bool()
                .expect(INTERNAL_ERR),
        )
    }
    pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        match call.input.get(0..4) {
            Some(signature) => Self::METHOD_ID == signature,
            None => false,
        }
    }
    pub fn call(&self, address: Vec<u8>) -> Option<bool> {
        use substreams_ethereum::pb::eth::rpc;
        let rpc_calls = rpc::RpcCalls {
            calls: vec![
                rpc::RpcCall { to_addr : address, data : self.encode(), }
            ],
        };
        let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
        let response = responses
            .get(0)
            .expect("one response should have existed");
        if response.failed {
            return None;
        }
        match Self::output(response.raw.as_ref()) {
            Ok(data) => Some(data),
            Err(err) => {
                use substreams_ethereum::Function;
                substreams::log::info!(
                    "Call output for function `{}` failed to decode with error: {}",
                    Self::NAME, err
                );
                None
            }
        }
    }
}
impl substreams_ethereum::Function for SupportsInterface {
    const NAME: &'static str = "supportsInterface";
    fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        Self::match_call(call)
    }
    fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        Self::decode(call)
    }
    fn encode(&self) -> Vec<u8> {
        self.encode()
    }
}
impl substreams_ethereum::rpc::RPCDecodable<bool> for SupportsInterface {
    fn output(data: &[u8]) -> Result<bool, String> {
        Self::output(data)
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct Symbol {}
impl Symbol {
    const METHOD_ID: [u8; 4] = [149u8, 216u8, 155u8, 65u8];
    pub fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        Ok(Self {})
    }
    pub fn encode(&self) -> Vec<u8> {
        let data = ethabi::encode(&[]);
        let mut encoded = Vec::with_capacity(4 + data.len());
        encoded.extend(Self::METHOD_ID);
        encoded.extend(data);
        encoded
    }
    pub fn output_call(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<String, String> {
        Self::output(call.return_data.as_ref())
    }
    pub fn output(data: &[u8]) -> Result<String, String> {
        let mut values = ethabi::decode(
                &[ethabi::ParamType::String],
                data.as_ref(),
            )
            .map_err(|e| format!("unable to decode output data: {:?}", e))?;
        Ok(
            values
                .pop()
                .expect("one output data should have existed")
                .into_string()
                .expect(INTERNAL_ERR),
        )
    }
    pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        match call.input.get(0..4) {
            Some(signature) => Self::METHOD_ID == signature,
            None => false,
        }
    }
    pub fn call(&self, address: Vec<u8>) -> Option<String> {
        use substreams_ethereum::pb::eth::rpc;
        let rpc_calls = rpc::RpcCalls {
            calls: vec![
                rpc::RpcCall { to_addr : address, data : self.encode(), }
            ],
        };
        let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
        let response = responses
            .get(0)
            .expect("one response should have existed");
        if response.failed {
            return None;
        }
        match Self::output(response.raw.as_ref()) {
            Ok(data) => Some(data),
            Err(err) => {
                use substreams_ethereum::Function;
                substreams::log::info!(
                    "Call output for function `{}` failed to decode with error: {}",
                    Self::NAME, err
                );
                None
            }
        }
    }
}
impl substreams_ethereum::Function for Symbol {
    const NAME: &'static str = "symbol";
    fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        Self::match_call(call)
    }
    fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        Self::decode(call)
    }
    fn encode(&self) -> Vec<u8> {
        self.encode()
    }
}
impl substreams_ethereum::rpc::RPCDecodable<String> for Symbol {
    fn output(data: &[u8]) -> Result<String, String> {
        Self::output(data)
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TokenByIndex {
    pub index: substreams::scalar::BigInt,
}
impl TokenByIndex {
    const METHOD_ID: [u8; 4] = [79u8, 108u8, 204u8, 231u8];
    pub fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        let maybe_data = call.input.get(4..);
        if maybe_data.is_none() {
            return Err("no data to decode".to_string());
        }
        let mut values = ethabi::decode(
                &[ethabi::ParamType::Uint(256usize)],
                maybe_data.unwrap(),
            )
            .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
        values.reverse();
        Ok(Self {
            index: {
                let mut v = [0 as u8; 32];
                values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_uint()
                    .expect(INTERNAL_ERR)
                    .to_big_endian(v.as_mut_slice());
                substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
            },
        })
    }
    pub fn encode(&self) -> Vec<u8> {
        let data = ethabi::encode(
            &[
                ethabi::Token::Uint(
                    ethabi::Uint::from_big_endian(
                        match self.index.clone().to_bytes_be() {
                            (num_bigint::Sign::Plus, bytes) => bytes,
                            (num_bigint::Sign::NoSign, bytes) => bytes,
                            (num_bigint::Sign::Minus, _) => {
                                panic!("negative numbers are not supported")
                            }
                        }
                            .as_slice(),
                    ),
                ),
            ],
        );
        let mut encoded = Vec::with_capacity(4 + data.len());
        encoded.extend(Self::METHOD_ID);
        encoded.extend(data);
        encoded
    }
    pub fn output_call(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<substreams::scalar::BigInt, String> {
        Self::output(call.return_data.as_ref())
    }
    pub fn output(data: &[u8]) -> Result<substreams::scalar::BigInt, String> {
        let mut values = ethabi::decode(
                &[ethabi::ParamType::Uint(256usize)],
                data.as_ref(),
            )
            .map_err(|e| format!("unable to decode output data: {:?}", e))?;
        Ok({
            let mut v = [0 as u8; 32];
            values
                .pop()
                .expect("one output data should have existed")
                .into_uint()
                .expect(INTERNAL_ERR)
                .to_big_endian(v.as_mut_slice());
            substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
        })
    }
    pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        match call.input.get(0..4) {
            Some(signature) => Self::METHOD_ID == signature,
            None => false,
        }
    }
    pub fn call(&self, address: Vec<u8>) -> Option<substreams::scalar::BigInt> {
        use substreams_ethereum::pb::eth::rpc;
        let rpc_calls = rpc::RpcCalls {
            calls: vec![
                rpc::RpcCall { to_addr : address, data : self.encode(), }
            ],
        };
        let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
        let response = responses
            .get(0)
            .expect("one response should have existed");
        if response.failed {
            return None;
        }
        match Self::output(response.raw.as_ref()) {
            Ok(data) => Some(data),
            Err(err) => {
                use substreams_ethereum::Function;
                substreams::log::info!(
                    "Call output for function `{}` failed to decode with error: {}",
                    Self::NAME, err
                );
                None
            }
        }
    }
}
impl substreams_ethereum::Function for TokenByIndex {
    const NAME: &'static str = "tokenByIndex";
    fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        Self::match_call(call)
    }
    fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        Self::decode(call)
    }
    fn encode(&self) -> Vec<u8> {
        self.encode()
    }
}
impl substreams_ethereum::rpc::RPCDecodable<substreams::scalar::BigInt>
for TokenByIndex {
    fn output(data: &[u8]) -> Result<substreams::scalar::BigInt, String> {
        Self::output(data)
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TokenOfOwnerByIndex {
    pub owner: Vec<u8>,
    pub index: substreams::scalar::BigInt,
}
impl TokenOfOwnerByIndex {
    const METHOD_ID: [u8; 4] = [47u8, 116u8, 92u8, 89u8];
    pub fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        let maybe_data = call.input.get(4..);
        if maybe_data.is_none() {
            return Err("no data to decode".to_string());
        }
        let mut values = ethabi::decode(
                &[ethabi::ParamType::Address, ethabi::ParamType::Uint(256usize)],
                maybe_data.unwrap(),
            )
            .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
        values.reverse();
        Ok(Self {
            owner: values
                .pop()
                .expect(INTERNAL_ERR)
                .into_address()
                .expect(INTERNAL_ERR)
                .as_bytes()
                .to_vec(),
            index: {
                let mut v = [0 as u8; 32];
                values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_uint()
                    .expect(INTERNAL_ERR)
                    .to_big_endian(v.as_mut_slice());
                substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
            },
        })
    }
    pub fn encode(&self) -> Vec<u8> {
        let data = ethabi::encode(
            &[
                ethabi::Token::Address(ethabi::Address::from_slice(&self.owner)),
                ethabi::Token::Uint(
                    ethabi::Uint::from_big_endian(
                        match self.index.clone().to_bytes_be() {
                            (num_bigint::Sign::Plus, bytes) => bytes,
                            (num_bigint::Sign::NoSign, bytes) => bytes,
                            (num_bigint::Sign::Minus, _) => {
                                panic!("negative numbers are not supported")
                            }
                        }
                            .as_slice(),
                    ),
                ),
            ],
        );
        let mut encoded = Vec::with_capacity(4 + data.len());
        encoded.extend(Self::METHOD_ID);
        encoded.extend(data);
        encoded
    }
    pub fn output_call(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<substreams::scalar::BigInt, String> {
        Self::output(call.return_data.as_ref())
    }
    pub fn output(data: &[u8]) -> Result<substreams::scalar::BigInt, String> {
        let mut values = ethabi::decode(
                &[ethabi::ParamType::Uint(256usize)],
                data.as_ref(),
            )
            .map_err(|e| format!("unable to decode output data: {:?}", e))?;
        Ok({
            let mut v = [0 as u8; 32];
            values
                .pop()
                .expect("one output data should have existed")
                .into_uint()
                .expect(INTERNAL_ERR)
                .to_big_endian(v.as_mut_slice());
            substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
        })
    }
    pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        match call.input.get(0..4) {
            Some(signature) => Self::METHOD_ID == signature,
            None => false,
        }
    }
    pub fn call(&self, address: Vec<u8>) -> Option<substreams::scalar::BigInt> {
        use substreams_ethereum::pb::eth::rpc;
        let rpc_calls = rpc::RpcCalls {
            calls: vec![
                rpc::RpcCall { to_addr : address, data : self.encode(), }
            ],
        };
        let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
        let response = responses
            .get(0)
            .expect("one response should have existed");
        if response.failed {
            return None;
        }
        match Self::output(response.raw.as_ref()) {
            Ok(data) => Some(data),
            Err(err) => {
                use substreams_ethereum::Function;
                substreams::log::info!(
                    "Call output for function `{}` failed to decode with error: {}",
                    Self::NAME, err
                );
                None
            }
        }
    }
}
impl substreams_ethereum::Function for TokenOfOwnerByIndex {
    const NAME: &'static str = "tokenOfOwnerByIndex";
    fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        Self::match_call(call)
    }
    fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        Self::decode(call)
    }
    fn encode(&self) -> Vec<u8> {
        self.encode()
    }
}
impl substreams_ethereum::rpc::RPCDecodable<substreams::scalar::BigInt>
for TokenOfOwnerByIndex {
    fn output(data: &[u8]) -> Result<substreams::scalar::BigInt, String> {
        Self::output(data)
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TokenUri {
    pub token_id: substreams::scalar::BigInt,
}
impl TokenUri {
    const METHOD_ID: [u8; 4] = [200u8, 123u8, 86u8, 221u8];
    pub fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        let maybe_data = call.input.get(4..);
        if maybe_data.is_none() {
            return Err("no data to decode".to_string());
        }
        let mut values = ethabi::decode(
                &[ethabi::ParamType::Uint(256usize)],
                maybe_data.unwrap(),
            )
            .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
        values.reverse();
        Ok(Self {
            token_id: {
                let mut v = [0 as u8; 32];
                values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_uint()
                    .expect(INTERNAL_ERR)
                    .to_big_endian(v.as_mut_slice());
                substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
            },
        })
    }
    pub fn encode(&self) -> Vec<u8> {
        let data = ethabi::encode(
            &[
                ethabi::Token::Uint(
                    ethabi::Uint::from_big_endian(
                        match self.token_id.clone().to_bytes_be() {
                            (num_bigint::Sign::Plus, bytes) => bytes,
                            (num_bigint::Sign::NoSign, bytes) => bytes,
                            (num_bigint::Sign::Minus, _) => {
                                panic!("negative numbers are not supported")
                            }
                        }
                            .as_slice(),
                    ),
                ),
            ],
        );
        let mut encoded = Vec::with_capacity(4 + data.len());
        encoded.extend(Self::METHOD_ID);
        encoded.extend(data);
        encoded
    }
    pub fn output_call(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<String, String> {
        Self::output(call.return_data.as_ref())
    }
    pub fn output(data: &[u8]) -> Result<String, String> {
        let mut values = ethabi::decode(
                &[ethabi::ParamType::String],
                data.as_ref(),
            )
            .map_err(|e| format!("unable to decode output data: {:?}", e))?;
        Ok(
            values
                .pop()
                .expect("one output data should have existed")
                .into_string()
                .expect(INTERNAL_ERR),
        )
    }
    pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        match call.input.get(0..4) {
            Some(signature) => Self::METHOD_ID == signature,
            None => false,
        }
    }
    pub fn call(&self, address: Vec<u8>) -> Option<String> {
        use substreams_ethereum::pb::eth::rpc;
        let rpc_calls = rpc::RpcCalls {
            calls: vec![
                rpc::RpcCall { to_addr : address, data : self.encode(), }
            ],
        };
        let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
        let response = responses
            .get(0)
            .expect("one response should have existed");
        if response.failed {
            return None;
        }
        match Self::output(response.raw.as_ref()) {
            Ok(data) => Some(data),
            Err(err) => {
                use substreams_ethereum::Function;
                substreams::log::info!(
                    "Call output for function `{}` failed to decode with error: {}",
                    Self::NAME, err
                );
                None
            }
        }
    }
}
impl substreams_ethereum::Function for TokenUri {
    const NAME: &'static str = "tokenURI";
    fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        Self::match_call(call)
    }
    fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        Self::decode(call)
    }
    fn encode(&self) -> Vec<u8> {
        self.encode()
    }
}
impl substreams_ethereum::rpc::RPCDecodable<String> for TokenUri {
    fn output(data: &[u8]) -> Result<String, String> {
        Self::output(data)
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TotalSupply {}
impl TotalSupply {
    const METHOD_ID: [u8; 4] = [24u8, 22u8, 13u8, 221u8];
    pub fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        Ok(Self {})
    }
    pub fn encode(&self) -> Vec<u8> {
        let data = ethabi::encode(&[]);
        let mut encoded = Vec::with_capacity(4 + data.len());
        encoded.extend(Self::METHOD_ID);
        encoded.extend(data);
        encoded
    }
    pub fn output_call(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<substreams::scalar::BigInt, String> {
        Self::output(call.return_data.as_ref())
    }
    pub fn output(data: &[u8]) -> Result<substreams::scalar::BigInt, String> {
        let mut values = ethabi::decode(
                &[ethabi::ParamType::Uint(256usize)],
                data.as_ref(),
            )
            .map_err(|e| format!("unable to decode output data: {:?}", e))?;
        Ok({
            let mut v = [0 as u8; 32];
            values
                .pop()
                .expect("one output data should have existed")
                .into_uint()
                .expect(INTERNAL_ERR)
                .to_big_endian(v.as_mut_slice());
            substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
        })
    }
    pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        match call.input.get(0..4) {
            Some(signature) => Self::METHOD_ID == signature,
            None => false,
        }
    }
    pub fn call(&self, address: Vec<u8>) -> Option<substreams::scalar::BigInt> {
        use substreams_ethereum::pb::eth::rpc;
        let rpc_calls = rpc::RpcCalls {
            calls: vec![
                rpc::RpcCall { to_addr : address, data : self.encode(), }
            ],
        };
        let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
        let response = responses
            .get(0)
            .expect("one response should have existed");
        if response.failed {
            return None;
        }
        match Self::output(response.raw.as_ref()) {
            Ok(data) => Some(data),
            Err(err) => {
                use substreams_ethereum::Function;
                substreams::log::info!(
                    "Call output for function `{}` failed to decode with error: {}",
                    Self::NAME, err
                );
                None
            }
        }
    }
}
impl substreams_ethereum::Function for TotalSupply {
    const NAME: &'static str = "totalSupply";
    fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        Self::match_call(call)
    }
    fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        Self::decode(call)
    }
    fn encode(&self) -> Vec<u8> {
        self.encode()
    }
}
impl substreams_ethereum::rpc::RPCDecodable<substreams::scalar::BigInt>
for TotalSupply {
    fn output(data: &[u8]) -> Result<substreams::scalar::BigInt, String> {
        Self::output(data)
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct TransferFrom {
    pub from: Vec<u8>,
    pub to: Vec<u8>,
    pub token_id: substreams::scalar::BigInt,
}
impl TransferFrom {
    const METHOD_ID: [u8; 4] = [35u8, 184u8, 114u8, 221u8];
    pub fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        let maybe_data = call.input.get(4..);
        if maybe_data.is_none() {
            return Err("no data to decode".to_string());
        }
        let mut values = ethabi::decode(
                &[
                    ethabi::ParamType::Address,
                    ethabi::ParamType::Address,
                    ethabi::ParamType::Uint(256usize),
                ],
                maybe_data.unwrap(),
            )
            .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
        values.reverse();
        Ok(Self {
            from: values
                .pop()
                .expect(INTERNAL_ERR)
                .into_address()
                .expect(INTERNAL_ERR)
                .as_bytes()
                .to_vec(),
            to: values
                .pop()
                .expect(INTERNAL_ERR)
                .into_address()
                .expect(INTERNAL_ERR)
                .as_bytes()
                .to_vec(),
            token_id: {
                let mut v = [0 as u8; 32];
                values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_uint()
                    .expect(INTERNAL_ERR)
                    .to_big_endian(v.as_mut_slice());
                substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
            },
        })
    }
    pub fn encode(&self) -> Vec<u8> {
        let data = ethabi::encode(
            &[
                ethabi::Token::Address(ethabi::Address::from_slice(&self.from)),
                ethabi::Token::Address(ethabi::Address::from_slice(&self.to)),
                ethabi::Token::Uint(
                    ethabi::Uint::from_big_endian(
                        match self.token_id.clone().to_bytes_be() {
                            (num_bigint::Sign::Plus, bytes) => bytes,
                            (num_bigint::Sign::NoSign, bytes) => bytes,
                            (num_bigint::Sign::Minus, _) => {
                                panic!("negative numbers are not supported")
                            }
                        }
                            .as_slice(),
                    ),
                ),
            ],
        );
        let mut encoded = Vec::with_capacity(4 + data.len());
        encoded.extend(Self::METHOD_ID);
        encoded.extend(data);
        encoded
    }
    pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        match call.input.get(0..4) {
            Some(signature) => Self::METHOD_ID == signature,
            None => false,
        }
    }
}
impl substreams_ethereum::Function for TransferFrom {
    const NAME: &'static str = "transferFrom";
    fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
        Self::match_call(call)
    }
    fn decode(
        call: &substreams_ethereum::pb::eth::v2::Call,
    ) -> Result<Self, String> {
        Self::decode(call)
    }
    fn encode(&self) -> Vec<u8> {
        self.encode()
    }
}
}
/// Contract's events.
#[allow(dead_code, unused_imports, unused_variables)]
pub mod events {
use super::INTERNAL_ERR;
#[derive(Debug, Clone, PartialEq)]
pub struct Approval {
    pub owner: Vec<u8>,
    pub approved: Vec<u8>,
    pub token_id: substreams::scalar::BigInt,
}
impl Approval {
    const TOPIC_ID: [u8; 32] = [
        140u8,
        91u8,
        225u8,
        229u8,
        235u8,
        236u8,
        125u8,
        91u8,
        209u8,
        79u8,
        113u8,
        66u8,
        125u8,
        30u8,
        132u8,
        243u8,
        221u8,
        3u8,
        20u8,
        192u8,
        247u8,
        178u8,
        41u8,
        30u8,
        91u8,
        32u8,
        10u8,
        200u8,
        199u8,
        195u8,
        185u8,
        37u8,
    ];
    pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
        if log.topics.len() != 4usize {
            return false;
        }
        if log.data.len() != 0usize {
            return false;
        }
        return log.topics.get(0).expect("bounds already checked").as_ref()
            == Self::TOPIC_ID;
    }
    pub fn decode(
        log: &substreams_ethereum::pb::eth::v2::Log,
    ) -> Result<Self, String> {
        Ok(Self {
            owner: ethabi::decode(
                    &[ethabi::ParamType::Address],
                    log.topics[1usize].as_ref(),
                )
                .map_err(|e| {
                    format!(
                        "unable to decode param 'owner' from topic of type 'address': {:?}",
                        e
                    )
                })?
                .pop()
                .expect(INTERNAL_ERR)
                .into_address()
                .expect(INTERNAL_ERR)
                .as_bytes()
                .to_vec(),
            approved: ethabi::decode(
                    &[ethabi::ParamType::Address],
                    log.topics[2usize].as_ref(),
                )
                .map_err(|e| {
                    format!(
                        "unable to decode param 'approved' from topic of type 'address': {:?}",
                        e
                    )
                })?
                .pop()
                .expect(INTERNAL_ERR)
                .into_address()
                .expect(INTERNAL_ERR)
                .as_bytes()
                .to_vec(),
            token_id: {
                let mut v = [0 as u8; 32];
                ethabi::decode(
                        &[ethabi::ParamType::Uint(256usize)],
                        log.topics[3usize].as_ref(),
                    )
                    .map_err(|e| {
                        format!(
                            "unable to decode param 'token_id' from topic of type 'uint256': {:?}",
                            e
                        )
                    })?
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_uint()
                    .expect(INTERNAL_ERR)
                    .to_big_endian(v.as_mut_slice());
                substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
            },
        })
    }
}
impl substreams_ethereum::Event for Approval {
    const NAME: &'static str = "Approval";
    fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
        Self::match_log(log)
    }
    fn decode(
        log: &substreams_ethereum::pb::eth::v2::Log,
    ) -> Result<Self, String> {
        Self::decode(log)
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct ApprovalForAll {
    pub owner: Vec<u8>,
    pub operator: Vec<u8>,
    pub approved: bool,
}
impl ApprovalForAll {
    const TOPIC_ID: [u8; 32] = [
        23u8,
        48u8,
        126u8,
        171u8,
        57u8,
        171u8,
        97u8,
        7u8,
        232u8,
        137u8,
        152u8,
        69u8,
        173u8,
        61u8,
        89u8,
        189u8,
        150u8,
        83u8,
        242u8,
        0u8,
        242u8,
        32u8,
        146u8,
        4u8,
        137u8,
        202u8,
        43u8,
        89u8,
        55u8,
        105u8,
        108u8,
        49u8,
    ];
    pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
        if log.topics.len() != 3usize {
            return false;
        }
        if log.data.len() != 32usize {
            return false;
        }
        return log.topics.get(0).expect("bounds already checked").as_ref()
            == Self::TOPIC_ID;
    }
    pub fn decode(
        log: &substreams_ethereum::pb::eth::v2::Log,
    ) -> Result<Self, String> {
        let mut values = ethabi::decode(
                &[ethabi::ParamType::Bool],
                log.data.as_ref(),
            )
            .map_err(|e| format!("unable to decode log.data: {:?}", e))?;
        values.reverse();
        Ok(Self {
            owner: ethabi::decode(
                    &[ethabi::ParamType::Address],
                    log.topics[1usize].as_ref(),
                )
                .map_err(|e| {
                    format!(
                        "unable to decode param 'owner' from topic of type 'address': {:?}",
                        e
                    )
                })?
                .pop()
                .expect(INTERNAL_ERR)
                .into_address()
                .expect(INTERNAL_ERR)
                .as_bytes()
                .to_vec(),
            operator: ethabi::decode(
                    &[ethabi::ParamType::Address],
                    log.topics[2usize].as_ref(),
                )
                .map_err(|e| {
                    format!(
                        "unable to decode param 'operator' from topic of type 'address': {:?}",
                        e
                    )
                })?
                .pop()
                .expect(INTERNAL_ERR)
                .into_address()
                .expect(INTERNAL_ERR)
                .as_bytes()
                .to_vec(),
            approved: values
                .pop()
                .expect(INTERNAL_ERR)
                .into_bool()
                .expect(INTERNAL_ERR),
        })
    }
}
impl substreams_ethereum::Event for ApprovalForAll {
    const NAME: &'static str = "ApprovalForAll";
    fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
        Self::match_log(log)
    }
    fn decode(
        log: &substreams_ethereum::pb::eth::v2::Log,
    ) -> Result<Self, String> {
        Self::decode(log)
    }
}
#[derive(Debug, Clone, PartialEq)]
pub struct Transfer {
    pub from: Vec<u8>,
    pub to: Vec<u8>,
    pub token_id: substreams::scalar::BigInt,
}
impl Transfer {
    const TOPIC_ID: [u8; 32] = [
        221u8,
        242u8,
        82u8,
        173u8,
        27u8,
        226u8,
        200u8,
        155u8,
        105u8,
        194u8,
        176u8,
        104u8,
        252u8,
        55u8,
        141u8,
        170u8,
        149u8,
        43u8,
        167u8,
        241u8,
        99u8,
        196u8,
        161u8,
        22u8,
        40u8,
        245u8,
        90u8,
        77u8,
        245u8,
        35u8,
        179u8,
        239u8,
    ];
    pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
        if log.topics.len() != 4usize {
            return false;
        }
        if log.data.len() != 0usize {
            return false;
        }
        return log.topics.get(0).expect("bounds already checked").as_ref()
            == Self::TOPIC_ID;
    }
    pub fn decode(
        log: &substreams_ethereum::pb::eth::v2::Log,
    ) -> Result<Self, String> {
        Ok(Self {
            from: ethabi::decode(
                    &[ethabi::ParamType::Address],
                    log.topics[1usize].as_ref(),
                )
                .map_err(|e| {
                    format!(
                        "unable to decode param 'from' from topic of type 'address': {:?}",
                        e
                    )
                })?
                .pop()
                .expect(INTERNAL_ERR)
                .into_address()
                .expect(INTERNAL_ERR)
                .as_bytes()
                .to_vec(),
            to: ethabi::decode(
                    &[ethabi::ParamType::Address],
                    log.topics[2usize].as_ref(),
                )
                .map_err(|e| {
                    format!(
                        "unable to decode param 'to' from topic of type 'address': {:?}",
                        e
                    )
                })?
                .pop()
                .expect(INTERNAL_ERR)
                .into_address()
                .expect(INTERNAL_ERR)
                .as_bytes()
                .to_vec(),
            token_id: {
                let mut v = [0 as u8; 32];
                ethabi::decode(
                        &[ethabi::ParamType::Uint(256usize)],
                        log.topics[3usize].as_ref(),
                    )
                    .map_err(|e| {
                        format!(
                            "unable to decode param 'token_id' from topic of type 'uint256': {:?}",
                            e
                        )
                    })?
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_uint()
                    .expect(INTERNAL_ERR)
                    .to_big_endian(v.as_mut_slice());
                substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
            },
        })
    }
}
impl substreams_ethereum::Event for Transfer {
    const NAME: &'static str = "Transfer";
    fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
        Self::match_log(log)
    }
    fn decode(
        log: &substreams_ethereum::pb::eth::v2::Log,
    ) -> Result<Self, String> {
        Self::decode(log)
    }
}
}