// @generated by protoc-gen-es v1.2.1 with parameter "target=ts"
// @generated from file sf/ethereum/type/v2/type.proto (package sf.ethereum.type.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";

/**
 * @generated from enum sf.ethereum.type.v2.TransactionTraceStatus
 */
export enum TransactionTraceStatus {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: SUCCEEDED = 1;
   */
  SUCCEEDED = 1,

  /**
   * @generated from enum value: FAILED = 2;
   */
  FAILED = 2,

  /**
   * @generated from enum value: REVERTED = 3;
   */
  REVERTED = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(TransactionTraceStatus)
proto3.util.setEnumType(TransactionTraceStatus, "sf.ethereum.type.v2.TransactionTraceStatus", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "SUCCEEDED" },
  { no: 2, name: "FAILED" },
  { no: 3, name: "REVERTED" },
]);

/**
 * @generated from enum sf.ethereum.type.v2.CallType
 */
export enum CallType {
  /**
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * direct? what's the name for `Call` alone?
   *
   * @generated from enum value: CALL = 1;
   */
  CALL = 1,

  /**
   * @generated from enum value: CALLCODE = 2;
   */
  CALLCODE = 2,

  /**
   * @generated from enum value: DELEGATE = 3;
   */
  DELEGATE = 3,

  /**
   * @generated from enum value: STATIC = 4;
   */
  STATIC = 4,

  /**
   * create2 ? any other form of calls?
   *
   * @generated from enum value: CREATE = 5;
   */
  CREATE = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(CallType)
proto3.util.setEnumType(CallType, "sf.ethereum.type.v2.CallType", [
  { no: 0, name: "UNSPECIFIED" },
  { no: 1, name: "CALL" },
  { no: 2, name: "CALLCODE" },
  { no: 3, name: "DELEGATE" },
  { no: 4, name: "STATIC" },
  { no: 5, name: "CREATE" },
]);

/**
 * @generated from message sf.ethereum.type.v2.Block
 */
export class Block extends Message<Block> {
  /**
   * Hash is the block's hash.
   *
   * @generated from field: bytes hash = 2;
   */
  hash = new Uint8Array(0);

  /**
   * Number is the block's height at which this block was mined.
   *
   * @generated from field: uint64 number = 3;
   */
  number = protoInt64.zero;

  /**
   * Size is the size in bytes of the RLP encoding of the block according to Ethereum
   * rules.
   *
   * @generated from field: uint64 size = 4;
   */
  size = protoInt64.zero;

  /**
   * Header contain's the block's header information like its parent hash, the merkel root hash
   * and all other information the form a block.
   *
   * @generated from field: sf.ethereum.type.v2.BlockHeader header = 5;
   */
  header?: BlockHeader;

  /**
   * Uncles represents block produced with a valid solution but were not actually choosen
   * as the canonical block for the given height so they are mostly "forked" blocks.
   *
   * If the Block has been produced using the Proof of Stake consensus algorithm, this
   * field will actually be always empty.
   *
   * @generated from field: repeated sf.ethereum.type.v2.BlockHeader uncles = 6;
   */
  uncles: BlockHeader[] = [];

  /**
   * TransactionTraces hold the execute trace of all the transactions that were executed
   * in this block. In in there that you will find most of the Ethereum data model.
   *
   * @generated from field: repeated sf.ethereum.type.v2.TransactionTrace transaction_traces = 10;
   */
  transactionTraces: TransactionTrace[] = [];

  /**
   * BalanceChanges here is the array of ETH transfer that happened at the block level
   * outside of the normal transaction flow of a block. The best example of this is mining
   * reward for the block mined, the transfer of ETH to the miner happens outside the normal
   * transaction flow of the chain and is recorded as a `BalanceChange` here since we cannot
   * attached it to any transaction.
   *
   * @generated from field: repeated sf.ethereum.type.v2.BalanceChange balance_changes = 11;
   */
  balanceChanges: BalanceChange[] = [];

  /**
   * CodeChanges here is the array of smart code change that happened that happened at the block level
   * outside of the normal transaction flow of a block. Some Ethereum's fork like BSC and Polygon
   * has some capabilities to upgrade internal smart contracts used usually to track the validator
   * list.
   *
   * On hard fork, some procedure runs to upgrade the smart contract code to a new version. In those
   * network, a `CodeChange` for each modified smart contract on upgrade would be present here. Note
   * that this happen rarely, so the vast majority of block will have an empty list here.
   *
   * @generated from field: repeated sf.ethereum.type.v2.CodeChange code_changes = 20;
   */
  codeChanges: CodeChange[] = [];

  /**
   * Ver represents that data model version of the block, it is used internally by Firehose on Ethereum
   * as a validation that we are reading the correct version.
   *
   * @generated from field: int32 ver = 1;
   */
  ver = 0;

  constructor(data?: PartialMessage<Block>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.ethereum.type.v2.Block";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "number", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "size", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "header", kind: "message", T: BlockHeader },
    { no: 6, name: "uncles", kind: "message", T: BlockHeader, repeated: true },
    { no: 10, name: "transaction_traces", kind: "message", T: TransactionTrace, repeated: true },
    { no: 11, name: "balance_changes", kind: "message", T: BalanceChange, repeated: true },
    { no: 20, name: "code_changes", kind: "message", T: CodeChange, repeated: true },
    { no: 1, name: "ver", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Block {
    return new Block().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Block {
    return new Block().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Block {
    return new Block().fromJsonString(jsonString, options);
  }

  static equals(a: Block | PlainMessage<Block> | undefined, b: Block | PlainMessage<Block> | undefined): boolean {
    return proto3.util.equals(Block, a, b);
  }
}

/**
 * @generated from message sf.ethereum.type.v2.BlockHeader
 */
export class BlockHeader extends Message<BlockHeader> {
  /**
   * @generated from field: bytes parent_hash = 1;
   */
  parentHash = new Uint8Array(0);

  /**
   * Uncle hash of the block, some reference it as `sha3Uncles`, but `sha3`` is badly worded, so we prefer `uncle_hash`, also
   * referred as `ommers` in EIP specification.
   *
   * If the Block containing this `BlockHeader` has been produced using the Proof of Stake
   * consensus algorithm, this field will actually be constant and set to `0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347`.
   *
   * @generated from field: bytes uncle_hash = 2;
   */
  uncleHash = new Uint8Array(0);

  /**
   * @generated from field: bytes coinbase = 3;
   */
  coinbase = new Uint8Array(0);

  /**
   * @generated from field: bytes state_root = 4;
   */
  stateRoot = new Uint8Array(0);

  /**
   * @generated from field: bytes transactions_root = 5;
   */
  transactionsRoot = new Uint8Array(0);

  /**
   * @generated from field: bytes receipt_root = 6;
   */
  receiptRoot = new Uint8Array(0);

  /**
   * @generated from field: bytes logs_bloom = 7;
   */
  logsBloom = new Uint8Array(0);

  /**
   * Difficulty is the difficulty of the Proof of Work algorithm that was required to compute a solution.
   *
   * If the Block containing this `BlockHeader` has been produced using the Proof of Stake
   * consensus algorithm, this field will actually be constant and set to `0x00`.
   *
   * @generated from field: sf.ethereum.type.v2.BigInt difficulty = 8;
   */
  difficulty?: BigInt;

  /**
   * TotalDifficulty is the sum of all previous blocks difficulty including this block difficulty.
   *
   * If the Block containing this `BlockHeader` has been produced using the Proof of Stake
   * consensus algorithm, this field will actually be constant and set to the terminal total difficulty
   * that was required to transition to Proof of Stake algorithm, which varies per network. It is set to
   * 58 750 000 000 000 000 000 000 on Ethereum Mainnet and to 10 790 000 on Ethereum Testnet Goerli.
   *
   * @generated from field: sf.ethereum.type.v2.BigInt total_difficulty = 17;
   */
  totalDifficulty?: BigInt;

  /**
   * @generated from field: uint64 number = 9;
   */
  number = protoInt64.zero;

  /**
   * @generated from field: uint64 gas_limit = 10;
   */
  gasLimit = protoInt64.zero;

  /**
   * @generated from field: uint64 gas_used = 11;
   */
  gasUsed = protoInt64.zero;

  /**
   * @generated from field: google.protobuf.Timestamp timestamp = 12;
   */
  timestamp?: Timestamp;

  /**
   * ExtraData is free-form bytes included in the block by the "miner". While on Yellow paper of
   * Ethereum this value is maxed to 32 bytes, other consensus algorithm like Clique and some other
   * forks are using bigger values to carry special consensus data.
   *
   * If the Block containing this `BlockHeader` has been produced using the Proof of Stake
   * consensus algorithm, this field is strictly enforced to be <= 32 bytes.
   *
   * @generated from field: bytes extra_data = 13;
   */
  extraData = new Uint8Array(0);

  /**
   * MixHash is used to prove, when combined with the `nonce` that sufficient amount of computation has been
   * achieved and that the solution found is valid.
   *
   * @generated from field: bytes mix_hash = 14;
   */
  mixHash = new Uint8Array(0);

  /**
   * Nonce is used to prove, when combined with the `mix_hash` that sufficient amount of computation has been
   * achieved and that the solution found is valid.
   *
   * If the Block containing this `BlockHeader` has been produced using the Proof of Stake
   * consensus algorithm, this field will actually be constant and set to `0`.
   *
   * @generated from field: uint64 nonce = 15;
   */
  nonce = protoInt64.zero;

  /**
   * Hash is the hash of the block which is actually the computation:
   *
   *  Keccak256(rlp([
   *    parent_hash,
   *    uncle_hash,
   *    coinbase,
   *    state_root,
   *    transactions_root,
   *    receipt_root,
   *    logs_bloom,
   *    difficulty,
   *    number,
   *    gas_limit,
   *    gas_used,
   *    timestamp,
   *    extra_data,
   *    mix_hash,
   *    nonce,
   *    base_fee_per_gas (to be included, only if London Fork is active)
   *    withdrawals_root (to be included, only if Shangai Fork is active)
   *  ]))
   *
   *
   * @generated from field: bytes hash = 16;
   */
  hash = new Uint8Array(0);

  /**
   * Base fee per gas according to EIP-1559 (e.g. London Fork) rules, only set if London is present/active on the chain.
   *
   * @generated from field: sf.ethereum.type.v2.BigInt base_fee_per_gas = 18;
   */
  baseFeePerGas?: BigInt;

  /**
   * Withdrawals root hash according to EIP-4895 (e.g. Shangai Fork) rules, only set if Shangai is present/active on the chain.
   *
   * @generated from field: bytes withdrawals_root = 19;
   */
  withdrawalsRoot = new Uint8Array(0);

  /**
   * @generated from field: sf.ethereum.type.v2.Uint64NestedArray tx_dependency = 20;
   */
  txDependency?: Uint64NestedArray;

  constructor(data?: PartialMessage<BlockHeader>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.ethereum.type.v2.BlockHeader";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parent_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "uncle_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "coinbase", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "state_root", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "transactions_root", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "receipt_root", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 7, name: "logs_bloom", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 8, name: "difficulty", kind: "message", T: BigInt },
    { no: 17, name: "total_difficulty", kind: "message", T: BigInt },
    { no: 9, name: "number", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 10, name: "gas_limit", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 11, name: "gas_used", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 12, name: "timestamp", kind: "message", T: Timestamp },
    { no: 13, name: "extra_data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 14, name: "mix_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 15, name: "nonce", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 16, name: "hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 18, name: "base_fee_per_gas", kind: "message", T: BigInt },
    { no: 19, name: "withdrawals_root", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 20, name: "tx_dependency", kind: "message", T: Uint64NestedArray },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BlockHeader {
    return new BlockHeader().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BlockHeader {
    return new BlockHeader().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BlockHeader {
    return new BlockHeader().fromJsonString(jsonString, options);
  }

  static equals(a: BlockHeader | PlainMessage<BlockHeader> | undefined, b: BlockHeader | PlainMessage<BlockHeader> | undefined): boolean {
    return proto3.util.equals(BlockHeader, a, b);
  }
}

/**
 * @generated from message sf.ethereum.type.v2.Uint64NestedArray
 */
export class Uint64NestedArray extends Message<Uint64NestedArray> {
  /**
   * @generated from field: repeated sf.ethereum.type.v2.Uint64Array val = 1;
   */
  val: Uint64Array[] = [];

  constructor(data?: PartialMessage<Uint64NestedArray>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.ethereum.type.v2.Uint64NestedArray";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "message", T: Uint64Array, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Uint64NestedArray {
    return new Uint64NestedArray().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Uint64NestedArray {
    return new Uint64NestedArray().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Uint64NestedArray {
    return new Uint64NestedArray().fromJsonString(jsonString, options);
  }

  static equals(a: Uint64NestedArray | PlainMessage<Uint64NestedArray> | undefined, b: Uint64NestedArray | PlainMessage<Uint64NestedArray> | undefined): boolean {
    return proto3.util.equals(Uint64NestedArray, a, b);
  }
}

/**
 * @generated from message sf.ethereum.type.v2.Uint64Array
 */
export class Uint64Array extends Message<Uint64Array> {
  /**
   * @generated from field: repeated uint64 val = 1;
   */
  val: bigint[] = [];

  constructor(data?: PartialMessage<Uint64Array>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.ethereum.type.v2.Uint64Array";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val", kind: "scalar", T: 4 /* ScalarType.UINT64 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Uint64Array {
    return new Uint64Array().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Uint64Array {
    return new Uint64Array().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Uint64Array {
    return new Uint64Array().fromJsonString(jsonString, options);
  }

  static equals(a: Uint64Array | PlainMessage<Uint64Array> | undefined, b: Uint64Array | PlainMessage<Uint64Array> | undefined): boolean {
    return proto3.util.equals(Uint64Array, a, b);
  }
}

/**
 * @generated from message sf.ethereum.type.v2.BigInt
 */
export class BigInt extends Message<BigInt> {
  /**
   * @generated from field: bytes bytes = 1;
   */
  bytes = new Uint8Array(0);

  constructor(data?: PartialMessage<BigInt>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.ethereum.type.v2.BigInt";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bytes", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BigInt {
    return new BigInt().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BigInt {
    return new BigInt().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BigInt {
    return new BigInt().fromJsonString(jsonString, options);
  }

  static equals(a: BigInt | PlainMessage<BigInt> | undefined, b: BigInt | PlainMessage<BigInt> | undefined): boolean {
    return proto3.util.equals(BigInt, a, b);
  }
}

/**
 * @generated from message sf.ethereum.type.v2.TransactionTrace
 */
export class TransactionTrace extends Message<TransactionTrace> {
  /**
   * consensus
   *
   * @generated from field: bytes to = 1;
   */
  to = new Uint8Array(0);

  /**
   * @generated from field: uint64 nonce = 2;
   */
  nonce = protoInt64.zero;

  /**
   * GasPrice represents the effective price that has been paid for each gas unit of this transaction. Over time, the
   * Ethereum rules changes regarding GasPrice field here. Before London fork, the GasPrice was always set to the
   * fixed gas price. After London fork, this value has different meaning depending on the transaction type (see `Type` field).
   *
   * In cases where `TransactionTrace.Type == TRX_TYPE_LEGACY || TRX_TYPE_ACCESS_LIST`, then GasPrice has the same meaning
   * as before the London fork.
   *
   * In cases where `TransactionTrace.Type == TRX_TYPE_DYNAMIC_FEE`, then GasPrice is the effective gas price paid
   * for the transaction which is equals to `BlockHeader.BaseFeePerGas + TransactionTrace.`
   *
   * @generated from field: sf.ethereum.type.v2.BigInt gas_price = 3;
   */
  gasPrice?: BigInt;

  /**
   * GasLimit is the maximum of gas unit the sender of the transaction is willing to consume when perform the EVM
   * execution of the whole transaction
   *
   * @generated from field: uint64 gas_limit = 4;
   */
  gasLimit = protoInt64.zero;

  /**
   * Value is the amount of Ether transferred as part of this transaction.
   *
   * @generated from field: sf.ethereum.type.v2.BigInt value = 5;
   */
  value?: BigInt;

  /**
   * Input data the transaction will receive for execution of EVM.
   *
   * @generated from field: bytes input = 6;
   */
  input = new Uint8Array(0);

  /**
   * V is the recovery ID value for the signature Y point.
   *
   * @generated from field: bytes v = 7;
   */
  v = new Uint8Array(0);

  /**
   * R is the signature's X point on the elliptic curve (32 bytes).
   *
   * @generated from field: bytes r = 8;
   */
  r = new Uint8Array(0);

  /**
   * S is the signature's Y point on the elliptic curve (32 bytes).
   *
   * @generated from field: bytes s = 9;
   */
  s = new Uint8Array(0);

  /**
   * GasUsed is the total amount of gas unit used for the whole execution of the transaction.
   *
   * @generated from field: uint64 gas_used = 10;
   */
  gasUsed = protoInt64.zero;

  /**
   * Type represents the Ethereum transaction type, available only since EIP-2718 & EIP-2930 activation which happened on Berlin fork.
   * The value is always set even for transaction before Berlin fork because those before the fork are still legacy transactions.
   *
   * @generated from field: sf.ethereum.type.v2.TransactionTrace.Type type = 12;
   */
  type = TransactionTrace_Type.TRX_TYPE_LEGACY;

  /**
   * AcccessList represents the storage access this transaction has agreed to do in which case those storage
   * access cost less gas unit per access.
   *
   * This will is populated only if `TransactionTrace.Type == TRX_TYPE_ACCESS_LIST || TRX_TYPE_DYNAMIC_FEE` which
   * is possible only if Berlin (TRX_TYPE_ACCESS_LIST) nor London (TRX_TYPE_DYNAMIC_FEE) fork are active on the chain.
   *
   * @generated from field: repeated sf.ethereum.type.v2.AccessTuple access_list = 14;
   */
  accessList: AccessTuple[] = [];

  /**
   * MaxFeePerGas is the maximum fee per gas the user is willing to pay for the transaction gas used.
   *
   * This will is populated only if `TransactionTrace.Type == TRX_TYPE_DYNAMIC_FEE` which is possible only
   * if Londong fork is active on the chain.
   *
   * @generated from field: sf.ethereum.type.v2.BigInt max_fee_per_gas = 11;
   */
  maxFeePerGas?: BigInt;

  /**
   * MaxPriorityFeePerGas is priority fee per gas the user to pay in extra to the miner on top of the block's
   * base fee.
   *
   * This will is populated only if `TransactionTrace.Type == TRX_TYPE_DYNAMIC_FEE` which is possible only
   * if Londong fork is active on the chain.
   *
   * @generated from field: sf.ethereum.type.v2.BigInt max_priority_fee_per_gas = 13;
   */
  maxPriorityFeePerGas?: BigInt;

  /**
   * meta
   *
   * @generated from field: uint32 index = 20;
   */
  index = 0;

  /**
   * @generated from field: bytes hash = 21;
   */
  hash = new Uint8Array(0);

  /**
   * @generated from field: bytes from = 22;
   */
  from = new Uint8Array(0);

  /**
   * @generated from field: bytes return_data = 23;
   */
  returnData = new Uint8Array(0);

  /**
   * @generated from field: bytes public_key = 24;
   */
  publicKey = new Uint8Array(0);

  /**
   * @generated from field: uint64 begin_ordinal = 25;
   */
  beginOrdinal = protoInt64.zero;

  /**
   * @generated from field: uint64 end_ordinal = 26;
   */
  endOrdinal = protoInt64.zero;

  /**
   * TransactionTraceStatus is the status of the transaction execution and will let you know if the transaction
   * was successful or not.
   *
   * A successful transaction has been recorded to the blockchain's state for calls in it that were successful.
   * This means it's possible only a subset of the calls were properly recorded, refer to [calls[].state_reverted] field
   * to determine which calls were reverted.
   *
   * A quirks of the Ethereum protocol is that a transaction `FAILED` or `REVERTED` still affects the blockchain's
   * state for **some** of the state changes. Indeed, in those cases, the transactions fees are still paid to the miner
   * which means there is a balance change for the transaction's emitter (e.g. `from`) to pay the gas fees, an optional
   * balance change for gas refunded to the transaction's emitter (e.g. `from`) and a balance change for the miner who
   * received the transaction fees. There is also a nonce change for the transaction's emitter (e.g. `from`).
   *
   * This means that to properly record the state changes for a transaction, you need to conditionally procees the
   * transaction's status.
   *
   * For a `SUCCEEDED` transaction, you iterate over the `calls` array and record the state changes for each call for
   * which `state_reverted == false` (if a transaction succeeded, the call at #0 will always `state_reverted == false`
   * because it aligns with the transaction).
   *
   * For a `FAILED` or `REVERTED` transaction, you iterate over the root call (e.g. at #0, will always exist) for
   * balance changes you process those where `reason` is either `REASON_GAS_BUY`, `REASON_GAS_REFUND` or
   * `REASON_REWARD_TRANSACTION_FEE` and for nonce change, still on the root call, you pick the nonce change which the
   * smallest ordinal (if more than one).
   *
   * @generated from field: sf.ethereum.type.v2.TransactionTraceStatus status = 30;
   */
  status = TransactionTraceStatus.UNKNOWN;

  /**
   * @generated from field: sf.ethereum.type.v2.TransactionReceipt receipt = 31;
   */
  receipt?: TransactionReceipt;

  /**
   * @generated from field: repeated sf.ethereum.type.v2.Call calls = 32;
   */
  calls: Call[] = [];

  constructor(data?: PartialMessage<TransactionTrace>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.ethereum.type.v2.TransactionTrace";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "to", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "nonce", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "gas_price", kind: "message", T: BigInt },
    { no: 4, name: "gas_limit", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "value", kind: "message", T: BigInt },
    { no: 6, name: "input", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 7, name: "v", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 8, name: "r", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 9, name: "s", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 10, name: "gas_used", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 12, name: "type", kind: "enum", T: proto3.getEnumType(TransactionTrace_Type) },
    { no: 14, name: "access_list", kind: "message", T: AccessTuple, repeated: true },
    { no: 11, name: "max_fee_per_gas", kind: "message", T: BigInt },
    { no: 13, name: "max_priority_fee_per_gas", kind: "message", T: BigInt },
    { no: 20, name: "index", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 21, name: "hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 22, name: "from", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 23, name: "return_data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 24, name: "public_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 25, name: "begin_ordinal", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 26, name: "end_ordinal", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 30, name: "status", kind: "enum", T: proto3.getEnumType(TransactionTraceStatus) },
    { no: 31, name: "receipt", kind: "message", T: TransactionReceipt },
    { no: 32, name: "calls", kind: "message", T: Call, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransactionTrace {
    return new TransactionTrace().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransactionTrace {
    return new TransactionTrace().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransactionTrace {
    return new TransactionTrace().fromJsonString(jsonString, options);
  }

  static equals(a: TransactionTrace | PlainMessage<TransactionTrace> | undefined, b: TransactionTrace | PlainMessage<TransactionTrace> | undefined): boolean {
    return proto3.util.equals(TransactionTrace, a, b);
  }
}

/**
 * @generated from enum sf.ethereum.type.v2.TransactionTrace.Type
 */
export enum TransactionTrace_Type {
  /**
   * All transactions that ever existed prior Berlin fork before EIP-2718 was implemented.
   *
   * @generated from enum value: TRX_TYPE_LEGACY = 0;
   */
  TRX_TYPE_LEGACY = 0,

  /**
   * Transaction that specicy an access list of contract/storage_keys that is going to be used
   * in this transaction.
   *
   * Added in Berlin fork (EIP-2930).
   *
   * @generated from enum value: TRX_TYPE_ACCESS_LIST = 1;
   */
  TRX_TYPE_ACCESS_LIST = 1,

  /**
   * Transaction that specifis an access list just like TRX_TYPE_ACCESS_LIST but in addition defines the
   * max base gas gee and max priority gas fee to pay for this transaction. Transaction's of those type are
   * executed against EIP-1559 rules which dictates a dynamic gas cost based on the congestion of the network.
   *
   * @generated from enum value: TRX_TYPE_DYNAMIC_FEE = 2;
   */
  TRX_TYPE_DYNAMIC_FEE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(TransactionTrace_Type)
proto3.util.setEnumType(TransactionTrace_Type, "sf.ethereum.type.v2.TransactionTrace.Type", [
  { no: 0, name: "TRX_TYPE_LEGACY" },
  { no: 1, name: "TRX_TYPE_ACCESS_LIST" },
  { no: 2, name: "TRX_TYPE_DYNAMIC_FEE" },
]);

/**
 * AccessTuple represents a list of storage keys for a given contract's address and is used
 * for AccessList construction.
 *
 * @generated from message sf.ethereum.type.v2.AccessTuple
 */
export class AccessTuple extends Message<AccessTuple> {
  /**
   * @generated from field: bytes address = 1;
   */
  address = new Uint8Array(0);

  /**
   * @generated from field: repeated bytes storage_keys = 2;
   */
  storageKeys: Uint8Array[] = [];

  constructor(data?: PartialMessage<AccessTuple>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.ethereum.type.v2.AccessTuple";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "storage_keys", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessTuple {
    return new AccessTuple().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessTuple {
    return new AccessTuple().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessTuple {
    return new AccessTuple().fromJsonString(jsonString, options);
  }

  static equals(a: AccessTuple | PlainMessage<AccessTuple> | undefined, b: AccessTuple | PlainMessage<AccessTuple> | undefined): boolean {
    return proto3.util.equals(AccessTuple, a, b);
  }
}

/**
 * @generated from message sf.ethereum.type.v2.TransactionReceipt
 */
export class TransactionReceipt extends Message<TransactionReceipt> {
  /**
   * State root is an intermediate state_root hash, computed in-between transactions to make
   * **sure** you could build a proof and point to state in the middle of a block. Geth client
   * uses `PostState + root + PostStateOrStatus`` while Parity used `status_code, root...`` this piles
   * hardforks, see (read the EIPs first):
   * - https://github.com/ethereum/EIPs/blob/master/EIPS/eip-658.md
   *
   * Moreover, the notion of `Outcome`` in parity, which segregates the two concepts, which are
   * stored in the same field `status_code`` can be computed based on such a hack of the `state_root`
   * field, following `EIP-658`.
   *
   * Before Byzantinium hard fork, this field is always empty.
   *
   * @generated from field: bytes state_root = 1;
   */
  stateRoot = new Uint8Array(0);

  /**
   * @generated from field: uint64 cumulative_gas_used = 2;
   */
  cumulativeGasUsed = protoInt64.zero;

  /**
   * @generated from field: bytes logs_bloom = 3;
   */
  logsBloom = new Uint8Array(0);

  /**
   * @generated from field: repeated sf.ethereum.type.v2.Log logs = 4;
   */
  logs: Log[] = [];

  constructor(data?: PartialMessage<TransactionReceipt>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.ethereum.type.v2.TransactionReceipt";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state_root", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "cumulative_gas_used", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "logs_bloom", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "logs", kind: "message", T: Log, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransactionReceipt {
    return new TransactionReceipt().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransactionReceipt {
    return new TransactionReceipt().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransactionReceipt {
    return new TransactionReceipt().fromJsonString(jsonString, options);
  }

  static equals(a: TransactionReceipt | PlainMessage<TransactionReceipt> | undefined, b: TransactionReceipt | PlainMessage<TransactionReceipt> | undefined): boolean {
    return proto3.util.equals(TransactionReceipt, a, b);
  }
}

/**
 * @generated from message sf.ethereum.type.v2.Log
 */
export class Log extends Message<Log> {
  /**
   * @generated from field: bytes address = 1;
   */
  address = new Uint8Array(0);

  /**
   * @generated from field: repeated bytes topics = 2;
   */
  topics: Uint8Array[] = [];

  /**
   * @generated from field: bytes data = 3;
   */
  data = new Uint8Array(0);

  /**
   * Index is the index of the log relative to the transaction. This index
   * is always populated regardless of the state revertion of the the call
   * that emitted this log.
   *
   * @generated from field: uint32 index = 4;
   */
  index = 0;

  /**
   * BlockIndex represents the index of the log relative to the Block.
   *
   * An **important** notice is that this field will be 0 when the call
   * that emitted the log has been reverted by the chain.
   *
   * Currently, there is two locations where a Log can be obtained:
   * - block.transaction_traces[].receipt.logs[]
   * - block.transaction_traces[].calls[].logs[]
   *
   * In the `receipt` case, the logs will be populated only when the call
   * that emitted them has not been reverted by the chain and when in this
   * position, the `blockIndex` is always populated correctly.
   *
   * In the case of `calls` case, for `call` where `stateReverted == true`,
   * the `blockIndex` value will always be 0.
   *
   * @generated from field: uint32 blockIndex = 6;
   */
  blockIndex = 0;

  /**
   * @generated from field: uint64 ordinal = 7;
   */
  ordinal = protoInt64.zero;

  constructor(data?: PartialMessage<Log>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.ethereum.type.v2.Log";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "topics", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
    { no: 3, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "index", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "blockIndex", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 7, name: "ordinal", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Log {
    return new Log().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Log {
    return new Log().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Log {
    return new Log().fromJsonString(jsonString, options);
  }

  static equals(a: Log | PlainMessage<Log> | undefined, b: Log | PlainMessage<Log> | undefined): boolean {
    return proto3.util.equals(Log, a, b);
  }
}

/**
 * @generated from message sf.ethereum.type.v2.Call
 */
export class Call extends Message<Call> {
  /**
   * @generated from field: uint32 index = 1;
   */
  index = 0;

  /**
   * @generated from field: uint32 parent_index = 2;
   */
  parentIndex = 0;

  /**
   * @generated from field: uint32 depth = 3;
   */
  depth = 0;

  /**
   * @generated from field: sf.ethereum.type.v2.CallType call_type = 4;
   */
  callType = CallType.UNSPECIFIED;

  /**
   * @generated from field: bytes caller = 5;
   */
  caller = new Uint8Array(0);

  /**
   * @generated from field: bytes address = 6;
   */
  address = new Uint8Array(0);

  /**
   * @generated from field: sf.ethereum.type.v2.BigInt value = 7;
   */
  value?: BigInt;

  /**
   * @generated from field: uint64 gas_limit = 8;
   */
  gasLimit = protoInt64.zero;

  /**
   * @generated from field: uint64 gas_consumed = 9;
   */
  gasConsumed = protoInt64.zero;

  /**
   * @generated from field: bytes return_data = 13;
   */
  returnData = new Uint8Array(0);

  /**
   * @generated from field: bytes input = 14;
   */
  input = new Uint8Array(0);

  /**
   * @generated from field: bool executed_code = 15;
   */
  executedCode = false;

  /**
   * @generated from field: bool suicide = 16;
   */
  suicide = false;

  /**
   * hex representation of the hash -> preimage 
   *
   * @generated from field: map<string, string> keccak_preimages = 20;
   */
  keccakPreimages: { [key: string]: string } = {};

  /**
   * @generated from field: repeated sf.ethereum.type.v2.StorageChange storage_changes = 21;
   */
  storageChanges: StorageChange[] = [];

  /**
   * @generated from field: repeated sf.ethereum.type.v2.BalanceChange balance_changes = 22;
   */
  balanceChanges: BalanceChange[] = [];

  /**
   * @generated from field: repeated sf.ethereum.type.v2.NonceChange nonce_changes = 24;
   */
  nonceChanges: NonceChange[] = [];

  /**
   * @generated from field: repeated sf.ethereum.type.v2.Log logs = 25;
   */
  logs: Log[] = [];

  /**
   * @generated from field: repeated sf.ethereum.type.v2.CodeChange code_changes = 26;
   */
  codeChanges: CodeChange[] = [];

  /**
   * @generated from field: repeated sf.ethereum.type.v2.GasChange gas_changes = 28;
   */
  gasChanges: GasChange[] = [];

  /**
   * In Ethereum, a call can be either:
   * - Successfull, execution passes without any problem encountered
   * - Failed, execution failed, and remaining gas should be consumed
   * - Reverted, execution failed, but only gas consumed so far is billed, remaining gas is refunded
   *
   * When a call is either `failed` or `reverted`, the `status_failed` field
   * below is set to `true`. If the status is `reverted`, then both `status_failed`
   * and `status_reverted` are going to be set to `true`.
   *
   * @generated from field: bool status_failed = 10;
   */
  statusFailed = false;

  /**
   * @generated from field: bool status_reverted = 12;
   */
  statusReverted = false;

  /**
   * Populated when a call either failed or reverted, so when `status_failed == true`,
   * see above for details about those flags.
   *
   * @generated from field: string failure_reason = 11;
   */
  failureReason = "";

  /**
   * This field represents wheter or not the state changes performed
   * by this call were correctly recorded by the blockchain.
   *
   * On Ethereum, a transaction can record state changes even if some
   * of its inner nested calls failed. This is problematic however since
   * a call will invalidate all its state changes as well as all state
   * changes performed by its child call. This means that even if a call
   * has a status of `SUCCESS`, the chain might have reverted all the state
   * changes it performed.
   *
   * ```text
   *   Trx 1
   *    Call #1 <Failed>
   *      Call #2 <Execution Success>
   *      Call #3 <Execution Success>
   *      |--- Failure here
   *    Call #4
   * ```
   *
   * In the transaction above, while Call #2 and Call #3 would have the
   * status `EXECUTED`.
   *
   * If you check all calls and check only `state_reverted` flag, you might be missing
   * some balance changes and nonce changes. This is because when a full transaction fails
   * in ethereum (e.g. `calls.all(x.state_reverted == true)`), there is still the transaction
   * fee that are recorded to the chain.
   *
   * Refer to [TransactionTrace#status] field for more details about the handling you must
   * perform.
   *
   * @generated from field: bool state_reverted = 30;
   */
  stateReverted = false;

  /**
   * @generated from field: uint64 begin_ordinal = 31;
   */
  beginOrdinal = protoInt64.zero;

  /**
   * @generated from field: uint64 end_ordinal = 32;
   */
  endOrdinal = protoInt64.zero;

  /**
   * @generated from field: repeated sf.ethereum.type.v2.AccountCreation account_creations = 33;
   */
  accountCreations: AccountCreation[] = [];

  constructor(data?: PartialMessage<Call>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.ethereum.type.v2.Call";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "index", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "parent_index", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "depth", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "call_type", kind: "enum", T: proto3.getEnumType(CallType) },
    { no: 5, name: "caller", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 7, name: "value", kind: "message", T: BigInt },
    { no: 8, name: "gas_limit", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 9, name: "gas_consumed", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 13, name: "return_data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 14, name: "input", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 15, name: "executed_code", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 16, name: "suicide", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 20, name: "keccak_preimages", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 21, name: "storage_changes", kind: "message", T: StorageChange, repeated: true },
    { no: 22, name: "balance_changes", kind: "message", T: BalanceChange, repeated: true },
    { no: 24, name: "nonce_changes", kind: "message", T: NonceChange, repeated: true },
    { no: 25, name: "logs", kind: "message", T: Log, repeated: true },
    { no: 26, name: "code_changes", kind: "message", T: CodeChange, repeated: true },
    { no: 28, name: "gas_changes", kind: "message", T: GasChange, repeated: true },
    { no: 10, name: "status_failed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "status_reverted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "failure_reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 30, name: "state_reverted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 31, name: "begin_ordinal", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 32, name: "end_ordinal", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 33, name: "account_creations", kind: "message", T: AccountCreation, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Call {
    return new Call().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Call {
    return new Call().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Call {
    return new Call().fromJsonString(jsonString, options);
  }

  static equals(a: Call | PlainMessage<Call> | undefined, b: Call | PlainMessage<Call> | undefined): boolean {
    return proto3.util.equals(Call, a, b);
  }
}

/**
 * @generated from message sf.ethereum.type.v2.StorageChange
 */
export class StorageChange extends Message<StorageChange> {
  /**
   * @generated from field: bytes address = 1;
   */
  address = new Uint8Array(0);

  /**
   * @generated from field: bytes key = 2;
   */
  key = new Uint8Array(0);

  /**
   * @generated from field: bytes old_value = 3;
   */
  oldValue = new Uint8Array(0);

  /**
   * @generated from field: bytes new_value = 4;
   */
  newValue = new Uint8Array(0);

  /**
   * @generated from field: uint64 ordinal = 5;
   */
  ordinal = protoInt64.zero;

  constructor(data?: PartialMessage<StorageChange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.ethereum.type.v2.StorageChange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "old_value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "new_value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "ordinal", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StorageChange {
    return new StorageChange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StorageChange {
    return new StorageChange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StorageChange {
    return new StorageChange().fromJsonString(jsonString, options);
  }

  static equals(a: StorageChange | PlainMessage<StorageChange> | undefined, b: StorageChange | PlainMessage<StorageChange> | undefined): boolean {
    return proto3.util.equals(StorageChange, a, b);
  }
}

/**
 * @generated from message sf.ethereum.type.v2.BalanceChange
 */
export class BalanceChange extends Message<BalanceChange> {
  /**
   * @generated from field: bytes address = 1;
   */
  address = new Uint8Array(0);

  /**
   * @generated from field: sf.ethereum.type.v2.BigInt old_value = 2;
   */
  oldValue?: BigInt;

  /**
   * @generated from field: sf.ethereum.type.v2.BigInt new_value = 3;
   */
  newValue?: BigInt;

  /**
   * @generated from field: sf.ethereum.type.v2.BalanceChange.Reason reason = 4;
   */
  reason = BalanceChange_Reason.UNKNOWN;

  /**
   * @generated from field: uint64 ordinal = 5;
   */
  ordinal = protoInt64.zero;

  constructor(data?: PartialMessage<BalanceChange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.ethereum.type.v2.BalanceChange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "old_value", kind: "message", T: BigInt },
    { no: 3, name: "new_value", kind: "message", T: BigInt },
    { no: 4, name: "reason", kind: "enum", T: proto3.getEnumType(BalanceChange_Reason) },
    { no: 5, name: "ordinal", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BalanceChange {
    return new BalanceChange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BalanceChange {
    return new BalanceChange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BalanceChange {
    return new BalanceChange().fromJsonString(jsonString, options);
  }

  static equals(a: BalanceChange | PlainMessage<BalanceChange> | undefined, b: BalanceChange | PlainMessage<BalanceChange> | undefined): boolean {
    return proto3.util.equals(BalanceChange, a, b);
  }
}

/**
 * Obtain all balanche change reasons under deep mind repository:
 *
 * ```shell
 * ack -ho 'BalanceChangeReason\(".*"\)' | grep -Eo '".*"' | sort | uniq
 * ```
 *
 * @generated from enum sf.ethereum.type.v2.BalanceChange.Reason
 */
export enum BalanceChange_Reason {
  /**
   * @generated from enum value: REASON_UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: REASON_REWARD_MINE_UNCLE = 1;
   */
  REWARD_MINE_UNCLE = 1,

  /**
   * @generated from enum value: REASON_REWARD_MINE_BLOCK = 2;
   */
  REWARD_MINE_BLOCK = 2,

  /**
   * @generated from enum value: REASON_DAO_REFUND_CONTRACT = 3;
   */
  DAO_REFUND_CONTRACT = 3,

  /**
   * @generated from enum value: REASON_DAO_ADJUST_BALANCE = 4;
   */
  DAO_ADJUST_BALANCE = 4,

  /**
   * @generated from enum value: REASON_TRANSFER = 5;
   */
  TRANSFER = 5,

  /**
   * @generated from enum value: REASON_GENESIS_BALANCE = 6;
   */
  GENESIS_BALANCE = 6,

  /**
   * @generated from enum value: REASON_GAS_BUY = 7;
   */
  GAS_BUY = 7,

  /**
   * @generated from enum value: REASON_REWARD_TRANSACTION_FEE = 8;
   */
  REWARD_TRANSACTION_FEE = 8,

  /**
   * @generated from enum value: REASON_REWARD_FEE_RESET = 14;
   */
  REWARD_FEE_RESET = 14,

  /**
   * @generated from enum value: REASON_GAS_REFUND = 9;
   */
  GAS_REFUND = 9,

  /**
   * @generated from enum value: REASON_TOUCH_ACCOUNT = 10;
   */
  TOUCH_ACCOUNT = 10,

  /**
   * @generated from enum value: REASON_SUICIDE_REFUND = 11;
   */
  SUICIDE_REFUND = 11,

  /**
   * @generated from enum value: REASON_SUICIDE_WITHDRAW = 13;
   */
  SUICIDE_WITHDRAW = 13,

  /**
   * @generated from enum value: REASON_CALL_BALANCE_OVERRIDE = 12;
   */
  CALL_BALANCE_OVERRIDE = 12,

  /**
   * Used on chain(s) where some Ether burning happens
   *
   * @generated from enum value: REASON_BURN = 15;
   */
  BURN = 15,

  /**
   * @generated from enum value: REASON_WITHDRAWAL = 16;
   */
  WITHDRAWAL = 16,
}
// Retrieve enum metadata with: proto3.getEnumType(BalanceChange_Reason)
proto3.util.setEnumType(BalanceChange_Reason, "sf.ethereum.type.v2.BalanceChange.Reason", [
  { no: 0, name: "REASON_UNKNOWN" },
  { no: 1, name: "REASON_REWARD_MINE_UNCLE" },
  { no: 2, name: "REASON_REWARD_MINE_BLOCK" },
  { no: 3, name: "REASON_DAO_REFUND_CONTRACT" },
  { no: 4, name: "REASON_DAO_ADJUST_BALANCE" },
  { no: 5, name: "REASON_TRANSFER" },
  { no: 6, name: "REASON_GENESIS_BALANCE" },
  { no: 7, name: "REASON_GAS_BUY" },
  { no: 8, name: "REASON_REWARD_TRANSACTION_FEE" },
  { no: 14, name: "REASON_REWARD_FEE_RESET" },
  { no: 9, name: "REASON_GAS_REFUND" },
  { no: 10, name: "REASON_TOUCH_ACCOUNT" },
  { no: 11, name: "REASON_SUICIDE_REFUND" },
  { no: 13, name: "REASON_SUICIDE_WITHDRAW" },
  { no: 12, name: "REASON_CALL_BALANCE_OVERRIDE" },
  { no: 15, name: "REASON_BURN" },
  { no: 16, name: "REASON_WITHDRAWAL" },
]);

/**
 * @generated from message sf.ethereum.type.v2.NonceChange
 */
export class NonceChange extends Message<NonceChange> {
  /**
   * @generated from field: bytes address = 1;
   */
  address = new Uint8Array(0);

  /**
   * @generated from field: uint64 old_value = 2;
   */
  oldValue = protoInt64.zero;

  /**
   * @generated from field: uint64 new_value = 3;
   */
  newValue = protoInt64.zero;

  /**
   * @generated from field: uint64 ordinal = 4;
   */
  ordinal = protoInt64.zero;

  constructor(data?: PartialMessage<NonceChange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.ethereum.type.v2.NonceChange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "old_value", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "new_value", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "ordinal", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NonceChange {
    return new NonceChange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NonceChange {
    return new NonceChange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NonceChange {
    return new NonceChange().fromJsonString(jsonString, options);
  }

  static equals(a: NonceChange | PlainMessage<NonceChange> | undefined, b: NonceChange | PlainMessage<NonceChange> | undefined): boolean {
    return proto3.util.equals(NonceChange, a, b);
  }
}

/**
 * @generated from message sf.ethereum.type.v2.AccountCreation
 */
export class AccountCreation extends Message<AccountCreation> {
  /**
   * @generated from field: bytes account = 1;
   */
  account = new Uint8Array(0);

  /**
   * @generated from field: uint64 ordinal = 2;
   */
  ordinal = protoInt64.zero;

  constructor(data?: PartialMessage<AccountCreation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.ethereum.type.v2.AccountCreation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "ordinal", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccountCreation {
    return new AccountCreation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccountCreation {
    return new AccountCreation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccountCreation {
    return new AccountCreation().fromJsonString(jsonString, options);
  }

  static equals(a: AccountCreation | PlainMessage<AccountCreation> | undefined, b: AccountCreation | PlainMessage<AccountCreation> | undefined): boolean {
    return proto3.util.equals(AccountCreation, a, b);
  }
}

/**
 * @generated from message sf.ethereum.type.v2.CodeChange
 */
export class CodeChange extends Message<CodeChange> {
  /**
   * @generated from field: bytes address = 1;
   */
  address = new Uint8Array(0);

  /**
   * @generated from field: bytes old_hash = 2;
   */
  oldHash = new Uint8Array(0);

  /**
   * @generated from field: bytes old_code = 3;
   */
  oldCode = new Uint8Array(0);

  /**
   * @generated from field: bytes new_hash = 4;
   */
  newHash = new Uint8Array(0);

  /**
   * @generated from field: bytes new_code = 5;
   */
  newCode = new Uint8Array(0);

  /**
   * @generated from field: uint64 ordinal = 6;
   */
  ordinal = protoInt64.zero;

  constructor(data?: PartialMessage<CodeChange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.ethereum.type.v2.CodeChange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "old_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "old_code", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "new_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "new_code", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "ordinal", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CodeChange {
    return new CodeChange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CodeChange {
    return new CodeChange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CodeChange {
    return new CodeChange().fromJsonString(jsonString, options);
  }

  static equals(a: CodeChange | PlainMessage<CodeChange> | undefined, b: CodeChange | PlainMessage<CodeChange> | undefined): boolean {
    return proto3.util.equals(CodeChange, a, b);
  }
}

/**
 * The gas change model represents the reason why some gas cost has occurred.
 * The gas is computed per actual op codes. Doing them completely might prove
 * overwhelming in most cases.
 *
 * Hence, we only index some of them, those that are costy like all the calls
 * one, log events, return data, etc.
 *
 * @generated from message sf.ethereum.type.v2.GasChange
 */
export class GasChange extends Message<GasChange> {
  /**
   * @generated from field: uint64 old_value = 1;
   */
  oldValue = protoInt64.zero;

  /**
   * @generated from field: uint64 new_value = 2;
   */
  newValue = protoInt64.zero;

  /**
   * @generated from field: sf.ethereum.type.v2.GasChange.Reason reason = 3;
   */
  reason = GasChange_Reason.UNKNOWN;

  /**
   * @generated from field: uint64 ordinal = 4;
   */
  ordinal = protoInt64.zero;

  constructor(data?: PartialMessage<GasChange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.ethereum.type.v2.GasChange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "old_value", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "new_value", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "reason", kind: "enum", T: proto3.getEnumType(GasChange_Reason) },
    { no: 4, name: "ordinal", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GasChange {
    return new GasChange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GasChange {
    return new GasChange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GasChange {
    return new GasChange().fromJsonString(jsonString, options);
  }

  static equals(a: GasChange | PlainMessage<GasChange> | undefined, b: GasChange | PlainMessage<GasChange> | undefined): boolean {
    return proto3.util.equals(GasChange, a, b);
  }
}

/**
 * Obtain all gas change reasons under deep mind repository:
 *
 * ```shell
 * ack -ho 'GasChangeReason\(".*"\)' | grep -Eo '".*"' | sort | uniq
 * ```
 *
 * @generated from enum sf.ethereum.type.v2.GasChange.Reason
 */
export enum GasChange_Reason {
  /**
   * @generated from enum value: REASON_UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: REASON_CALL = 1;
   */
  CALL = 1,

  /**
   * @generated from enum value: REASON_CALL_CODE = 2;
   */
  CALL_CODE = 2,

  /**
   * @generated from enum value: REASON_CALL_DATA_COPY = 3;
   */
  CALL_DATA_COPY = 3,

  /**
   * @generated from enum value: REASON_CODE_COPY = 4;
   */
  CODE_COPY = 4,

  /**
   * @generated from enum value: REASON_CODE_STORAGE = 5;
   */
  CODE_STORAGE = 5,

  /**
   * @generated from enum value: REASON_CONTRACT_CREATION = 6;
   */
  CONTRACT_CREATION = 6,

  /**
   * @generated from enum value: REASON_CONTRACT_CREATION2 = 7;
   */
  CONTRACT_CREATION2 = 7,

  /**
   * @generated from enum value: REASON_DELEGATE_CALL = 8;
   */
  DELEGATE_CALL = 8,

  /**
   * @generated from enum value: REASON_EVENT_LOG = 9;
   */
  EVENT_LOG = 9,

  /**
   * @generated from enum value: REASON_EXT_CODE_COPY = 10;
   */
  EXT_CODE_COPY = 10,

  /**
   * @generated from enum value: REASON_FAILED_EXECUTION = 11;
   */
  FAILED_EXECUTION = 11,

  /**
   * @generated from enum value: REASON_INTRINSIC_GAS = 12;
   */
  INTRINSIC_GAS = 12,

  /**
   * @generated from enum value: REASON_PRECOMPILED_CONTRACT = 13;
   */
  PRECOMPILED_CONTRACT = 13,

  /**
   * @generated from enum value: REASON_REFUND_AFTER_EXECUTION = 14;
   */
  REFUND_AFTER_EXECUTION = 14,

  /**
   * @generated from enum value: REASON_RETURN = 15;
   */
  RETURN = 15,

  /**
   * @generated from enum value: REASON_RETURN_DATA_COPY = 16;
   */
  RETURN_DATA_COPY = 16,

  /**
   * @generated from enum value: REASON_REVERT = 17;
   */
  REVERT = 17,

  /**
   * @generated from enum value: REASON_SELF_DESTRUCT = 18;
   */
  SELF_DESTRUCT = 18,

  /**
   * @generated from enum value: REASON_STATIC_CALL = 19;
   */
  STATIC_CALL = 19,

  /**
   * Added in Berlin fork (Geth 1.10+)
   *
   * @generated from enum value: REASON_STATE_COLD_ACCESS = 20;
   */
  STATE_COLD_ACCESS = 20,
}
// Retrieve enum metadata with: proto3.getEnumType(GasChange_Reason)
proto3.util.setEnumType(GasChange_Reason, "sf.ethereum.type.v2.GasChange.Reason", [
  { no: 0, name: "REASON_UNKNOWN" },
  { no: 1, name: "REASON_CALL" },
  { no: 2, name: "REASON_CALL_CODE" },
  { no: 3, name: "REASON_CALL_DATA_COPY" },
  { no: 4, name: "REASON_CODE_COPY" },
  { no: 5, name: "REASON_CODE_STORAGE" },
  { no: 6, name: "REASON_CONTRACT_CREATION" },
  { no: 7, name: "REASON_CONTRACT_CREATION2" },
  { no: 8, name: "REASON_DELEGATE_CALL" },
  { no: 9, name: "REASON_EVENT_LOG" },
  { no: 10, name: "REASON_EXT_CODE_COPY" },
  { no: 11, name: "REASON_FAILED_EXECUTION" },
  { no: 12, name: "REASON_INTRINSIC_GAS" },
  { no: 13, name: "REASON_PRECOMPILED_CONTRACT" },
  { no: 14, name: "REASON_REFUND_AFTER_EXECUTION" },
  { no: 15, name: "REASON_RETURN" },
  { no: 16, name: "REASON_RETURN_DATA_COPY" },
  { no: 17, name: "REASON_REVERT" },
  { no: 18, name: "REASON_SELF_DESTRUCT" },
  { no: 19, name: "REASON_STATIC_CALL" },
  { no: 20, name: "REASON_STATE_COLD_ACCESS" },
]);

/**
 * HeaderOnlyBlock is used to optimally unpack the [Block] structure (note the
 * corresponding message number for the `header` field) while consuming less
 * memory, when only the `header` is desired.
 *
 * WARN: this is a client-side optimization pattern and should be moved in the
 * consuming code.
 *
 * @generated from message sf.ethereum.type.v2.HeaderOnlyBlock
 */
export class HeaderOnlyBlock extends Message<HeaderOnlyBlock> {
  /**
   * @generated from field: sf.ethereum.type.v2.BlockHeader header = 5;
   */
  header?: BlockHeader;

  constructor(data?: PartialMessage<HeaderOnlyBlock>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.ethereum.type.v2.HeaderOnlyBlock";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 5, name: "header", kind: "message", T: BlockHeader },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HeaderOnlyBlock {
    return new HeaderOnlyBlock().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HeaderOnlyBlock {
    return new HeaderOnlyBlock().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HeaderOnlyBlock {
    return new HeaderOnlyBlock().fromJsonString(jsonString, options);
  }

  static equals(a: HeaderOnlyBlock | PlainMessage<HeaderOnlyBlock> | undefined, b: HeaderOnlyBlock | PlainMessage<HeaderOnlyBlock> | undefined): boolean {
    return proto3.util.equals(HeaderOnlyBlock, a, b);
  }
}

/**
 * BlockWithRefs is a lightweight block, with traces and transactions
 * purged from the `block` within, and only.  It is used in transports
 * to pass block data around.
 *
 * @generated from message sf.ethereum.type.v2.BlockWithRefs
 */
export class BlockWithRefs extends Message<BlockWithRefs> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: sf.ethereum.type.v2.Block block = 2;
   */
  block?: Block;

  /**
   * @generated from field: sf.ethereum.type.v2.TransactionRefs transaction_trace_refs = 3;
   */
  transactionTraceRefs?: TransactionRefs;

  /**
   * @generated from field: bool irreversible = 4;
   */
  irreversible = false;

  constructor(data?: PartialMessage<BlockWithRefs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.ethereum.type.v2.BlockWithRefs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "block", kind: "message", T: Block },
    { no: 3, name: "transaction_trace_refs", kind: "message", T: TransactionRefs },
    { no: 4, name: "irreversible", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BlockWithRefs {
    return new BlockWithRefs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BlockWithRefs {
    return new BlockWithRefs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BlockWithRefs {
    return new BlockWithRefs().fromJsonString(jsonString, options);
  }

  static equals(a: BlockWithRefs | PlainMessage<BlockWithRefs> | undefined, b: BlockWithRefs | PlainMessage<BlockWithRefs> | undefined): boolean {
    return proto3.util.equals(BlockWithRefs, a, b);
  }
}

/**
 * @generated from message sf.ethereum.type.v2.TransactionTraceWithBlockRef
 */
export class TransactionTraceWithBlockRef extends Message<TransactionTraceWithBlockRef> {
  /**
   * @generated from field: sf.ethereum.type.v2.TransactionTrace trace = 1;
   */
  trace?: TransactionTrace;

  /**
   * @generated from field: sf.ethereum.type.v2.BlockRef block_ref = 2;
   */
  blockRef?: BlockRef;

  constructor(data?: PartialMessage<TransactionTraceWithBlockRef>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.ethereum.type.v2.TransactionTraceWithBlockRef";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "trace", kind: "message", T: TransactionTrace },
    { no: 2, name: "block_ref", kind: "message", T: BlockRef },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransactionTraceWithBlockRef {
    return new TransactionTraceWithBlockRef().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransactionTraceWithBlockRef {
    return new TransactionTraceWithBlockRef().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransactionTraceWithBlockRef {
    return new TransactionTraceWithBlockRef().fromJsonString(jsonString, options);
  }

  static equals(a: TransactionTraceWithBlockRef | PlainMessage<TransactionTraceWithBlockRef> | undefined, b: TransactionTraceWithBlockRef | PlainMessage<TransactionTraceWithBlockRef> | undefined): boolean {
    return proto3.util.equals(TransactionTraceWithBlockRef, a, b);
  }
}

/**
 * @generated from message sf.ethereum.type.v2.TransactionRefs
 */
export class TransactionRefs extends Message<TransactionRefs> {
  /**
   * @generated from field: repeated bytes hashes = 1;
   */
  hashes: Uint8Array[] = [];

  constructor(data?: PartialMessage<TransactionRefs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.ethereum.type.v2.TransactionRefs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hashes", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransactionRefs {
    return new TransactionRefs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransactionRefs {
    return new TransactionRefs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransactionRefs {
    return new TransactionRefs().fromJsonString(jsonString, options);
  }

  static equals(a: TransactionRefs | PlainMessage<TransactionRefs> | undefined, b: TransactionRefs | PlainMessage<TransactionRefs> | undefined): boolean {
    return proto3.util.equals(TransactionRefs, a, b);
  }
}

/**
 * @generated from message sf.ethereum.type.v2.BlockRef
 */
export class BlockRef extends Message<BlockRef> {
  /**
   * @generated from field: bytes hash = 1;
   */
  hash = new Uint8Array(0);

  /**
   * @generated from field: uint64 number = 2;
   */
  number = protoInt64.zero;

  constructor(data?: PartialMessage<BlockRef>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.ethereum.type.v2.BlockRef";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "number", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BlockRef {
    return new BlockRef().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BlockRef {
    return new BlockRef().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BlockRef {
    return new BlockRef().fromJsonString(jsonString, options);
  }

  static equals(a: BlockRef | PlainMessage<BlockRef> | undefined, b: BlockRef | PlainMessage<BlockRef> | undefined): boolean {
    return proto3.util.equals(BlockRef, a, b);
  }
}

